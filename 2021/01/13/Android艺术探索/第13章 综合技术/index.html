<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>第十三章 综合技术 | Junyong Tu の 杂记</title><meta name="author" content="Junyong Tu"><meta name="copyright" content="Junyong Tu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本章介绍的主题在日常开发中使用频率略低，但是对它们有一定的了解仍然是很有必要的，下面分别介绍它们的使用场景。 我们知道，不管程序怎么写都很难避免不crash，当程序crash后虽然无法让其再继续运行，但是如果能够知道程序crash的原因，那么就可以修复错误。但是很多时候产品发布后，如果用户在使用时发生了crash，这个crash信息是很难获取到的，这非常不利于一个产品的持续发展。其实可以通过Cra">
<meta property="og:type" content="article">
<meta property="og:title" content="第十三章 综合技术">
<meta property="og:url" content="https://github.com/juncaixingchi1993/juncaixingchi1993.github.io/2021/01/13/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC13%E7%AB%A0%20%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/index.html">
<meta property="og:site_name" content="Junyong Tu の 杂记">
<meta property="og:description" content="本章介绍的主题在日常开发中使用频率略低，但是对它们有一定的了解仍然是很有必要的，下面分别介绍它们的使用场景。 我们知道，不管程序怎么写都很难避免不crash，当程序crash后虽然无法让其再继续运行，但是如果能够知道程序crash的原因，那么就可以修复错误。但是很多时候产品发布后，如果用户在使用时发生了crash，这个crash信息是很难获取到的，这非常不利于一个产品的持续发展。其实可以通过Cra">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2Fd5f80e1a-f4c1-4f5c-aad2-fe213ae89f64%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1710160772&t=4038984b7822fc46c9a8d50e0c5106b4">
<meta property="article:published_time" content="2021-01-13T14:07:08.000Z">
<meta property="article:modified_time" content="2024-02-14T11:24:03.885Z">
<meta property="article:author" content="Junyong Tu">
<meta property="article:tag" content="android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2Fd5f80e1a-f4c1-4f5c-aad2-fe213ae89f64%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1710160772&t=4038984b7822fc46c9a8d50e0c5106b4"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://github.com/juncaixingchi1993/juncaixingchi1993.github.io/2021/01/13/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC13%E7%AB%A0%20%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第十三章 综合技术',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-14 19:24:03'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2Fd5f80e1a-f4c1-4f5c-aad2-fe213ae89f64%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&amp;refer=http%3A%2F%2Fsafe-img.xhscdn.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1710160772&amp;t=4038984b7822fc46c9a8d50e0c5106b4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img2.baidu.com/it/u=1361506290,4036378790&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500')"><nav id="nav"><span id="blog-info"><a href="/" title="Junyong Tu の 杂记"><span class="site-name">Junyong Tu の 杂记</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第十三章 综合技术</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-13T14:07:08.000Z" title="发表于 2021-01-13 22:07:08">2021-01-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-14T11:24:03.885Z" title="更新于 2024-02-14 19:24:03">2024-02-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/">艺术探索</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="第十三章 综合技术"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本章介绍的主题在日常开发中使用频率略低，但是对它们有一定的了解仍然是很有必要的，下面分别介绍它们的使用场景。</p>
<p>我们知道，不管程序怎么写都很难避免不crash，当程序crash后虽然无法让其再继续运行，但是如果能够知道程序crash的原因，那么就可以修复错误。但是很多时候产品发布后，如果用户在使用时发生了crash，这个crash信息是很难获取到的，这非常不利于一个产品的持续发展。其实可以通过CrashHandler来监视应用的crash信息，给程序设置一个CrashHandler，这样当程序crash时就会调用CrashHandler的uncaughtException方法。在这个方法中我们可以获取crash信息并上传到服务器，通过这种方式服务端就能监控程序的运行状况了，在后续的版本开发中，开发人员就可以对一些错误进行修复了。</p>
<p>在Android中，有一个限制，那就是整个应用的方法数不能超过65536，否则就会出现编译错误，并且程序也无法成功地安装到手机上。当项目日益庞大后这个问题就比较容易遇到，Google提供了multidex方案专门用于解决这个问题，通过将一个dex文件拆分为多个dex文件来避免单个dex文件方法数越界的问题。</p>
<p>方法数越界的另一种解决方案是动态加载</p>
<p>。动态加载可以直接加载一个dex形式的文件，将部分代码打包到一个单独的dex文件中（也可以是dex格式的jar或者apk），并在程序运行时根据需要去动态加载dex中的类，这种方式既可以解决缓解方法数越界的问题，也可以为程序提供按需加载的特性，同时这还为应用按模块更新提供了可能性。</p>
<p>反编译在应用开发中用得不是很多，但是很多时候我们需要研究其他产品的实现思路，这个时候就需要反编译了。在Android中反编译主要通过dex2jar以及apktool来完成。dex2jar可以将一个apk转成一个jar包，这个jar包再通过反编译工具jd-gui来打开就可以查看到反编译后的Java代码了。Apktool主要用于应用的解包和二次打包，实际上通过Apktool的二次打包可以做很多事情，甚至是一些违法的事情。目前不少公司都有专门的反编译团队，也称逆向团队，他们做的事情会更加深入，但是对于应用开发者来说并不需要了解那么多深入的逆向知识，因此本章仅仅介绍一些简单常用的反编译方法。</p>
<h2 id="13-1-使用CrashHandler来获取应用的crash信息"><a href="#13-1-使用CrashHandler来获取应用的crash信息" class="headerlink" title="13.1　使用CrashHandler来获取应用的crash信息"></a>13.1　使用CrashHandler来获取应用的crash信息</h2><p>Android应用不可避免地会发生crash，也称之为崩溃，无论你的程序写得多么完美，总是无法完全避免crash的发生，可能是由于Android系统底层的bug，也可能是由于不充分的机</p>
<p>型适配或者是糟糕的网络状况。当crash发生时，系统会kill掉正在执行的程序，现象就是闪退或者提示用户程序已停止运行，这对用户来说是很不友好的，也是开发者所不愿意看到的。更糟糕的是，当用户发生了crash，开发者却无法得知程序为何crash，即便开发人员想去解决这个crash，但是由于无法知道用户当时的crash信息，所以往往也无能为力。幸运的是，Android提供了处理这类问题的方法，请看下面Thread类中的一个方法setDefaultUncaughtExceptionHandler：</p>
<p>&#x2F;**</p>
<p>      * Sets the default uncaught exception handler. This handler is invoked in</p>
<p>      * case any Thread dies due to an unhandled exception.</p>
<p>      *</p>
<p>      * @param handler</p>
<p>      *            The handler to set or null.</p>
<p>      *&#x2F;</p>
<p>    public static void setDefaultUncaughtExceptionHandler(UncaughtException-</p>
<p>    Handler handler) {</p>
<p>        Thread.defaultUncaughtHandler &#x3D; handler;</p>
<p>    }</p>
<p>从方法的字面意义来看，这个方法好像可以设置系统的默认异常处理器，其实这个方法就可以解决上面所提到的crash问题。当crash发生的时候，系统就会回调UncaughtExceptionHandler的uncaughtException方法，在uncaughtException方法中就可以获取到异常信息，可以选择把异常信息存储到SD卡中，然后在合适</p>
<p>的时机通过网络将crash信息上传到服务器上，这样开发人员就可以分析用户crash的场景从而在后面的版本中修复此类crash。我们还可以在crash发生时，弹出一个对话框告诉用户程序crash了，然后再退出，这样做比闪退要温和一点。</p>
<p>有了上面的分析，现在读者肯定知道获取应用crash信息的方式了。首先需要实现一个UncaughtExceptionHandler对象，在它的uncaughtException方法中获取异常信息并将其存储在SD卡中或者上传到服务器供开发人员分析，然后调用Thread的setDefaultUncaught-ExceptionHandler方法将它设置为线程默认的异常处理器，由于默认异常处理器是Thread类的静态成员，因此它的作用对象是当前进程的所有线程。这么来看监听应用的crash信息实际上是很简单的一件事，下面是一个典型的异常处理器的实现：</p>
<p>public class CrashHandler implements UncaughtExceptionHandler {</p>
<p>         private static final String TAG &#x3D; “CrashHandler”;</p>
<p>         private static final boolean DEBUG &#x3D; true;</p>
<p>         private static final String PATH &#x3D; Environment.getExternal-StorageDirectory().getPath() + “&#x2F;CrashTest&#x2F;log&#x2F;“;</p>
<p>         private static final String FILE_NAME &#x3D; “crash”;</p>
<p>         private static final String FILE_NAME_SUFFIX &#x3D; “.trace”</p>
<p>;</p>
<p>         private static CrashHandler sInstance &#x3D; new CrashHandler();</p>
<p>         private UncaughtExceptionHandler mDefaultCrashHandler;</p>
<p>         private Context mContext;</p>
<p>         private CrashHandler() {</p>
<p>         }</p>
<p>         public static CrashHandler getInstance() {</p>
<p>             return sInstance;</p>
<p>         }</p>
<p>         public void init(Context context) {</p>
<p>             mDefaultCrashHandler &#x3D; Thread.getDefaultUncaughtExceptionHandler();</p>
<p>             Thread.setDefaultUncaughtExceptionHandler(this);</p>
<p>             mContext &#x3D; context.getApplicationContext();</p>
<p>         }</p>
<p>         &#x2F;**</p>
<p>          * 这个是最关键的函数，当程序中有未被捕获的异常，系统将会自动调用#uncaught-</p>
<p>            Exception方法</p>
<p>          * thread为出现未捕获异常的线程，ex为未捕获的异常，有了这个ex，我们就可以得到异</p>
<p>            常信息</p>
<p>          *&#x2F;</p>
<p>         @Override</p>
<p>         public void uncaughtException(Thread thread,Throwable ex) {</p>
<p>             try {</p>
<p>                 &#x2F;&#x2F;导出异常信息到SD卡中</p>
<p>                 dumpExceptionToSDCard(ex);</p>
<p>                 &#x2F;&#x2F;这里可以上传异常信息到服务器，便于开发人员分析日志从而解决bug</p>
<p>                 uploadExceptionToServer();</p>
<p>             } catch (IOException </p>
<p>e) {</p>
<p>                 e.printStackTrace();</p>
<p>             }</p>
<p>             ex.printStackTrace();</p>
<p>             &#x2F;&#x2F;如果系统提供了默认的异常处理器，则交给系统去结束程序，否则就由自己结束自己</p>
<p>             if (mDefaultCrashHandler !&#x3D; null) {</p>
<p>                 mDefaultCrashHandler.uncaughtException(thread,ex);</p>
<p>             } else {</p>
<p>                 Process.killProcess(Process.myPid());</p>
<p>             }</p>
<p>         }</p>
<p>         private void dumpExceptionToSDCard(Throwable ex) throws IOException {</p>
<p>             &#x2F;&#x2F;如果SD卡不存在或无法使用，则无法把异常信息写入SD卡</p>
<p>             if (!Environment.getExternalStorageState().equals(Environment.</p>
<p>             MEDIA_MOUNTED))            {</p>
<p>                 if (DEBUG) {</p>
<p>                     Log.w(TAG,”sdcard unmounted,skip dump exception”);</p>
<p>                     return;</p>
<p>                 }</p>
<p>             }</p>
<p>             File dir &#x3D; new File(PATH);</p>
<p>             if (!dir.exists()) {</p>
<p>                 dir.mkdirs();</p>
<p>             }</p>
<p>             long current &#x3D; System.currentTimeMillis();</p>
<p>             String time &#x3D; new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”).format(new</p>
<p>             Date(current));</p>
<p>             File file &#x3D; new File(PATH + FILE_NAM</p>
<p>E + time + FILE_NAME_SUFFIX);</p>
<p>             try {</p>
<p>                 PrintWriter pw &#x3D; new PrintWriter(new BufferedWriter(new</p>
<p>                 FileWriter(file)));</p>
<p>                 pw.println(time);</p>
<p>                 dumpPhoneInfo(pw);</p>
<p>                 pw.println();</p>
<p>                 ex.printStackTrace(pw);</p>
<p>                 pw.close();</p>
<p>             } catch (Exception e) {</p>
<p>                 Log.e(TAG,”dump crash info failed”);</p>
<p>             }</p>
<p>         }</p>
<p>         private void dumpPhoneInfo(PrintWriter pw)throws NameNotFoundException{</p>
<p>             PackageManager pm &#x3D; mContext.getPackageManager();</p>
<p>             PackageInfo pi &#x3D; pm.getPackageInfo(mContext.getPackageName(),</p>
<p>             PackageManager.GET_ACTIVITIES);</p>
<p>             pw.print(“App Version: “);</p>
<p>             pw.print(pi.versionName);</p>
<p>             pw.print(‘_’);</p>
<p>             pw.println(pi.versionCode);</p>
<p>             &#x2F;&#x2F;Android版本号</p>
<p>             pw.print(“OS Version: “);</p>
<p>             pw.print(Build.VERSION.RELEASE);</p>
<p>             pw.print(“_”);</p>
<p>             pw.println(Build.VERSION.SDK_INT);</p>
<p>             &#x2F;&#x2F;手机制造商</p>
<p>             pw.print(“Vendor: “);</p>
<p>             pw.println(Build.MANUFACTURER);</p>
<p>             &#x2F;&#x2F;手机</p>
<p>型号</p>
<p>             pw.print(“Model: “);</p>
<p>             pw.println(Build.MODEL);</p>
<p>             &#x2F;&#x2F;CPU架构</p>
<p>             pw.print(“CPU ABI: “);</p>
<p>             pw.println(Build.CPU_ABI);</p>
<p>         }</p>
<p>         private void uploadExceptionToServer() {</p>
<p>           &#x2F;&#x2F;TODO Upload Exception Message To Your Web Server</p>
<p>         }</p>
<p>    }</p>
<p>从上面的代码可以看出，当应用崩溃时，CrashHandler会将异常信息以及设备信息写入SD卡，接着将异常交给系统处理，系统会帮我们中止程序，如果系统没有默认的异常处理机制，那么就自行中止。当然也可以选择将异常信息上传到服务器，本节中的CrashHandler并没有实现这个逻辑，但是在实际开发中一般都需要将异常信息上传到服 务器。</p>
<p>如何使用上面的CrashHandler呢？也很简单，可以选择在Application初始化的时候为线程设置CrashHandler，如下所示。</p>
<p>public class TestApp extends Application {</p>
<p>         private static TestApp sInstance;</p>
<p>         @Override</p>
<p>         public void onCreate() {</p>
<p>             super.onCreate();</p>
<p>             sInstance &#x3D; this;</p>
<p>             &#x2F;&#x2F;在这里为应用设置异常处理，然后程序才能获取未处理的异常</p>
<p>             CrashHandler crashHandler &#x3D; CrashHandler.getInst</p>
<p>ance();</p>
<p>             crashHandler.init(this);</p>
<p>         }</p>
<p>         public static TestApp getInstance() {</p>
<p>             return sInstance;</p>
<p>         }</p>
<p>    }</p>
<p>经过上面两个步骤，程序就可以处理未处理的异常了，就再也不怕程序crash了，同时还可以很方便地从服务器上查看用户的crash信息。需要注意的是，代码中被catch的异常不会交给CrashHandler处理，CrashHandler只能收到那些未被捕获的异常。下面我们就模拟一下发生crash的情形，看程序是如何处理的，如下所示。</p>
<p>public class CrashActivity extends Activity implements OnClickListener {</p>
<p>         private Button mButton;</p>
<p>         @Override</p>
<p>         protected void onCreate(Bundle savedInstanceState) {</p>
<p>             super.onCreate(savedInstanceState);</p>
<p>             setContentView(R.layout.activity_crash);</p>
<p>             initView();</p>
<p>         }</p>
<p>         private void initView() {</p>
<p>             mButton &#x3D; (Button) findViewById(R.id.button1);</p>
<p>             mButton.setOnClickListener(this);</p>
<p>         }</p>
<p>         @Override</p>
<p>         public void onClick(View v) {</p>
<p>             if (v &#x3D;&#x3D; mButton) {</p>
<p>                 &#x2F;&#x2F; 在这里模拟异常抛出情况，人为地抛出一个</p>
<p>运行时异常</p>
<p>                 throw new RuntimeException(“自定义异常：这是自己抛出的异常”);</p>
<p>             }</p>
<p>         }</p>
<p>    }</p>
<p>在上面的测试代码中，给按钮加一个单击事件，在onClick中人为抛出一个运行时异常，这个时候程序就crash了，看看异常处理器为我们做了什么。从图13-1中可以看出，异常处理器为我们创建了一个日志文件，打开日志文件，可以看到手机的信息以及异常发生时的调用栈，有了这些内容，开发人员就很容易定位问题了。从图13-1中的函数调用栈可以看出，CrashActivity的28行发生了RuntimeException，再看一下CrashActivity的代码，发现28行的确抛出了一个RuntimeException，这说明CrashHandler已经成功地获取了未被捕获的异常信息，从现在开始，为应用加上默认异常事件处理器吧。</p>
<p>图13-1　CrashHandler获取的异常信息</p>
<h2 id="13-2-使用multidex来解决方法数越界"><a href="#13-2-使用multidex来解决方法数越界" class="headerlink" title="13.2　使用multidex来解决方法数越界"></a>13.2　使用multidex来解决方法数越界</h2><p>在Android中单个dex文件所能够包含的最大方法数为65536，这包含Android FrameWork、依赖的jar包以及应用本身的代码中的所有方法。65536是一个很大的数，一般来说一个简单应用的方法数的确很难达到65536，但是对于一些比较大型的应用来说，65536就很容易达到了。当应用的方法数达到65536后，编译器就无法完成编译工作并抛出类似下面的异常：</p>
<p>UNEXPECTED TOP-LEVEL EXCEPTION:</p>
<p>    com.android.dex.DexIndexOverflowException: method ID not in [0,0xffff]:</p>
<p>    65536</p>
<p>        at com.android.dx.merge.DexMerger$6.updateIndex(DexMerger.java:502)</p>
<p>        at com.android.dx.merge.DexMerger$IdMerger.mergeSorted(DexMerger.java:283)</p>
<p>        at com.android.dx.merge.DexMerger.mergeMethodIds(DexMerger.java:491)</p>
<p>        at com.android.dx.merge.DexMerger.mergeDexes(DexMerger.java:168)</p>
<p>        at com.android.dx.merge.DexMerger.merge(DexMerger.java:189)</p>
<p>        at com.android.dx.command.dexer.Main.mergeLibraryDexBuffers(Main.java:454)</p>
<p>        at com.android.dx.command.dexer.Main.runMonoDex(Main.java:303)</p>
<p>        at com.android.dx.command.dexer.Main.run(Main.java:246)</p>
<p>        at com.android.dx.command.dexer.Main.main(Main.java:215)</p>
<p>        at com.android.dx.command.Main.main(Main.java:106)</p>
<p>另外一种情况有所不同，有时候方法数并没有达到65536，并且编译器也正常地完成了编译工作，但是应用在低版本手机安装时异常中止，异常信息如下：</p>
<pre><code>E/dalvikvm: Optimization failed
</code></pre>
<p>    E&#x2F;installd: dexopt failed on ‘&#x2F;data&#x2F;dalvik-cache&#x2F;data@<a href="mailto:&#97;&#112;&#112;&#x40;&#x63;&#111;&#109;&#46;&#x72;&#x79;&#x67;">&#97;&#112;&#112;&#x40;&#x63;&#111;&#109;&#46;&#x72;&#x79;&#x67;</a>.</p>
<p>    <a href="mailto:&#109;&#117;&#108;&#x74;&#x69;&#100;&#x65;&#x78;&#116;&#101;&#x73;&#x74;&#x2d;&#x32;&#46;&#97;&#112;&#107;&#64;&#99;&#108;&#97;&#x73;&#x73;&#x65;&#115;&#x2e;&#100;&#101;&#x78;">&#109;&#117;&#108;&#x74;&#x69;&#100;&#x65;&#x78;&#116;&#101;&#x73;&#x74;&#x2d;&#x32;&#46;&#97;&#112;&#107;&#64;&#99;&#108;&#97;&#x73;&#x73;&#x65;&#115;&#x2e;&#100;&#101;&#x78;</a>‘ res &#x3D; 65280</p>
<p>为什么会出现这种情况呢？其实是这样的，dexopt是一个程序，应用在安装时，系统会通过dexopt来优化dex文件，在优化过程中dexopt采用一个固定大小的缓冲区来存储应用中所有方法的信息，这个缓冲区就是LinearAlloc。LinearAlloc缓冲区在新版本的Android系统中其大小是8MB或者16MB，但是在Android 2.2和2.3中却只有5MB，当待安装的apk中的方法数比较多时，尽管它还没有达到65536这个上限，但是它的存储空间仍然有可能超出5MB，这种情况下dexopt程序就会报错，从而导致安装失败，这种情况主要在2.x系列的手机上出现。</p>
<p>可以看到，不管是编译时方法数越界还是安装时的dexopt错误，它们都给开发过程带来了很大的困扰。从目前的Android版本的市场占有率来说，Android 3.0以下的手机仍然占据着不到10％的比率，目前主流的应用都不可能放弃Android 3.0以下的用户，对于这些应用来说，方法数越界就是一个必须要解决的问题了。</p>
<p>如何解决方法数越界的问题呢？我们首先想到的肯定是删除无用的代码和第三方库。没错，这的确是必须要做的工作，但是很多情况下即使删除了无用的代码，方法数仍然越界，这个时候该怎么办呢？针对这个问题，之前很多应用都会考虑采用插件化的机制来动态加载部分dex，通过将一个dex拆分成两个或多个dex，这就在一定程度上解决了方法数越界的问题。但是插件化是一套重量级的技术方案，并且其兼容性问题往往较多，从单纯解决方法数越界的角度来说，插件化并不是一个非常适合的方案，关于插件化的意义将在第13.3节中进行介绍。为了解决这个问题，Google在2014年提出了multidex的解决方案，通过multidex可以很好地解决方法数越界的问题，并且使用起来非常简单。</p>
<p>在Android 5.0以前使用multidex需要引入Google提供的android-support-multidex.jar这个jar包，这个jar包可以在Android SDK目录下的extras&#x2F;android&#x2F;support&#x2F;multidex&#x2F;library&#x2F; libs下面找到。从Android 5.0开始，Android默认支持了multidex，它可以从apk中加载多个dex文件。Multidex方案主要是针对AndroidStudio和Gradle编译环境的，如果是Eclipse和ant那就复杂一些，而且由于AndroidStudio作为官方IDE其最终会完全替代Eclipse ADT，因此本节中也不再介绍Eclipse中配置multidex的细节了。</p>
<p>在AndroidStudio和Gradle编译环境中，如果要使用multidex，首先要使用Android SDK Build Tools 21.1及以上版本，接着修改工程中app目录下的build.gradle文件，在defaultConfig中添加multiDexEnabled true这个配置项，如下所示。关于如何使用AndroidStudio和Gradle请读者自行查看相关资料，这里不再介绍。</p>
<p>android {</p>
<p>         compileSdkVersion 22</p>
<p>         buildToolsVersion “22.0.1”</p>
<p>         defaultConfig {</p>
<p>             applicationId “com.ryg.multidextest”</p>
<p>             minSdkVersion 8</p>
<p>             targetSdkVersion 22</p>
<p>             versionCode 1</p>
<p>             versionName “1.0”</p>
<p>             &#x2F;&#x2F; enable multidex support</p>
<p>             multiDexEnabled true</p>
<p>         }</p>
<p>        …</p>
<p>    }</p>
<p>接着还需要在dependencies中添加multidex的依赖：compile ‘com.android.support: multidex:1.0.0’，如下所示。</p>
<p>dependencies {</p>
<p>         compile fileTree(d</p>
<p>ir: ‘libs’,include: [‘*.jar’])</p>
<p>         compile ‘com.android.support:appcompat-v7:22.1.1’</p>
<p>         compile ‘com.android.support:multidex:1.0.0’</p>
<p>    }</p>
<p>最终配置完成的build.gradle文件如下所示，其中加粗的部分是专门为multidex所添加的配置项：</p>
<p>apply plugin: ‘com.android.application’</p>
<p>    android {</p>
<p>         compileSdkVersion 22</p>
<p>         buildToolsVersion “22.0.1”</p>
<p>         defaultConfig {</p>
<p>             applicationId “com.ryg.multidextest”</p>
<p>             minSdkVersion 8</p>
<p>             targetSdkVersion 22</p>
<p>             versionCode 1</p>
<p>             versionName “1.0”</p>
<p>             &#x2F;&#x2F; enable multidex support</p>
<p>             multiDexEnabled true</p>
<p>         }</p>
<p>         buildTypes {</p>
<p>             release {</p>
<p>                 minifyEnabled false</p>
<p>                 proguardFiles getDefaultProguardFile(‘proguard-android.txt’),</p>
<p>                 ‘proguard-rules.pro’</p>
<p>             }</p>
<p>         }</p>
<p>    }</p>
<p>    dependencies {</p>
<p>         compile fileTree(dir: ‘libs’,include: [‘*.jar’])</p>
<p>         compile ‘com.android.support:appcompat-v7:22.1.1’</p>
<p>         compile ‘com.android.support:multidex:1.0.0’</p>
<p>    }</p>
<p>经过了上面的过程，还需要做另一项工作，那就是在代码中加入支持multidex的功能，这个过程是比较简单的，有三种方案可以选。</p>
<p>第一种方案，在manifest文件中指定Application为MultiDexApplication，如下所示。</p>
<p>&lt;application</p>
<p>        android:name&#x3D;”android.support.multidex.MultiDexApplication”</p>
<p>        android:allowBackup&#x3D;”true”</p>
<p>        android:icon&#x3D;”@mipmap&#x2F;ic_launcher”</p>
<p>        android:label&#x3D;”@string&#x2F;app_name”</p>
<p>        android:theme&#x3D;”@style&#x2F;AppTheme” &gt;</p>
<p>        …</p>
<p>    </application></p>
<p>第二种方案，让应用的Application继承MultiDexApplication，比如：</p>
<p>public class TestApplication extends MultiDexApplication {</p>
<p>        …</p>
<p>    }</p>
<p>第三种方案，如果不想让应用的Application继承MultiDexApplication，还可以选择重写Application的attachBaseContext方法，这个方法比Application的onCreate要先执行，如下所示。</p>
<p>public class TestApplication extends Application {</p>
<p>         @Override</p>
<p>         protected void attachBaseContext(Context base) {</p>
<p>             super.attachBaseContext(</p>
<p>base);</p>
<p>             MultiDex.install(this);</p>
<p>         }</p>
<p>    }</p>
<p>现在所有的工作都已经完成了，可以发现应用不但可以编译通过了并且还可以在Android 2.x手机上面正常安装了。可以发现，multidex使用起来还是很简单的，对于一个使用multidex方案的应用，采用了上面的配置项，如果这个应用的方法数没有越界，那么Gradle并不会生成多个dex文件，如果方法数越界后，Gradle就会在apk中打包2个或多个dex文件，具体会打包多少个dex文件要看当前项目的代码规模。图13-2展示了采用multidex方案的apk中多个dex的分布情形。</p>
<p>图13-2　普通apk和采用multidex方案的apk</p>
<p>上面介绍的是multidex默认的配置，还可以通过build.gradle文件中一些其他配置项来定制dex文件的生成过程。在有些情况下，可能需要指定主dex文件中所要包含的类，这个</p>
<p>时候就可以通过–main-dex-list选项来实现这个功能。下面是修改后的build.gradle文件，在里面添加了afterEvaluate区域，在afterEvaluate区域内部采用了–main-dex-list选项来指定主dex中要包含的类，如下所示。</p>
<p>apply plugin: ‘com.android.application’</p>
<p>    android {</p>
<p>         compileSdkVersion 22</p>
<p>         buildToolsVersion “22.0.1”</p>
<p>         defaultConfig {</p>
<p>             applicationId “com.ryg.multidextest”</p>
<p>             minSdkVersion 8</p>
<p>             targetSdkVersion 22</p>
<p>             versionCode 1</p>
<p>             versionName “1.0”</p>
<p>             &#x2F;&#x2F; enable multidex support</p>
<p>             multiDexEnabled true</p>
<p>         }</p>
<p>         buildTypes {</p>
<p>             release {</p>
<p>                 minifyEnabled false</p>
<p>                 proguardFiles getDefaultProguardFile(‘proguard-android.txt’),</p>
<p>                ‘proguard-rules.pro’</p>
<p>             }</p>
<p>         }</p>
<p>    }</p>
<p>    afterEvaluate {println “afterEvaluate”tasks.matching {it.name.startsWith(‘dex’)}.each { dx -&gt;def listFile &#x3D; project.rootDir.absolutePath + ‘&#x2F;app&#x2F;maindexlist.txt’println “root dir:” + project.rootDir.absolutePathprintln “dex task found: “ + dx.name</p>
<p>if (dx.additionalParameters &#x3D;&#x3D; null) {dx.additionalParameters &#x3D; []}dx.additionalParameters +&#x3D; ‘–multi-dex’dx.additionalParameters +&#x3D; ‘–main-dex-list&#x3D;’ + listFiledx.additionalParameters +&#x3D; ‘–minimal-main-dex’}}</p>
<p>    dependencies {</p>
<p>         compile fileTree(dir: ‘libs’,include: [‘*.jar’])</p>
<p>         compile ‘com.android.support:appcompat-v7:22.1.1’</p>
<p>         compile ‘com.android.support:multidex:1.0.0’</p>
<p>    }</p>
<p>在上面的配置文件中，–multi-dex表示当方法数越界时则生成多个dex文件，–main-dex-list指定了要在主dex中打包的类的列表，–minimal-main-dex表明只有–main-dex-list所指定的类才能打包到主dex中。它的输入是一个文件，在上面的配置中，它的输入是工程中app目录下的maindexlist.txt这个文件，在maindexlist.txt中则指定了一系列的类，所有在maindexlist.txt中的类都会被打包到主dex中。注意maindexlist.txt这个文件名是可以修改的，但是它的内容必须要遵守一定的格式，下面是一个示例，这种格式是固定的。</p>
<pre><code>com/ryg/multidextest/TestApplication.class
</code></pre>
<p>    com&#x2F;ryg&#x2F;multidextest&#x2F;MainActivity.class</p>
<p>    &#x2F;&#x2F; multidex</p>
<p>    android&#x2F;support&#x2F;multidex&#x2F;MultiDex.class</p>
<p>    android&#x2F;support&#x2F;multidex&#x2F;MultiDexApplication.class</p>
<p>    android&#x2F;support&#x2F;multidex&#x2F;MultiDexExtractor.class</p>
<p>    android&#x2F;support&#x2F;multidex&#x2F;MultiDexExtractor$1.class</p>
<p>    android&#x2F;support&#x2F;multidex&#x2F;MultiDex$V4.class</p>
<p>    android&#x2F;support&#x2F;multidex&#x2F;MultiDex$V14.class</p>
<p>    android&#x2F;support&#x2F;multidex&#x2F;MultiDex$V19.class</p>
<p>    android&#x2F;support&#x2F;multidex&#x2F;ZipUtil.class</p>
<p>    android&#x2F;support&#x2F;multidex&#x2F;ZipUtil$CentralDirectory.class</p>
<p>程序编译后可以反编译apk中生成的主dex文件，可以发现主dex文件的确只有maindexlist.txt文件中所声明的类，读者可以自行尝试。maindexlist.txt这个文件很多时候都是可以通过脚本来自动生成内容的，这个脚本需要根据当前的项目自行实现，如果不采用脚本，人工编辑maindexlist.txt也是可以的。</p>
<p>需要注意的是，multidex的jar包中的9个类必须也要打包到主dex中，否则程序运行时会抛出异常，告知无法找到multidex相关的类。这是因为Application对象被创建以后会在attachBaseContext方法中通过MultiDex.install(this)来加载其他dex文件，这个时候如果MultiDex相关的类不在主dex中，很显然这些类是无法被加载的，那么程序执行就会出错。同时由于Application的成员和代码块会先于attachBaseContext方法而初始化，而这个时候其他dex文件还没有被加载，因此不能在Application的</p>
<p>成员以及代码块中访问其他dex中的类，否则程序也会因为无法加载对应的类而中止执行。在下面的代码中，模拟了这种场景，在Application的成员中使用了其他dex文件中的类View1。</p>
<p>public class TestApplication extends Application {</p>
<p>         private View1 view1 &#x3D; new View1();</p>
<p>         @Override</p>
<p>         protected void attachBaseContext(Context base) {</p>
<p>             super.attachBaseContext(base);</p>
<p>             MultiDex.install(this);</p>
<p>         }</p>
<p>    }</p>
<p>上面的代码会导致如下运行错误，因此在实际开发中要避免这个错误。</p>
<p>E&#x2F;AndroidRuntime: FATAL EXCEPTION: main</p>
<p>    Process: com.ryg.multidextest,PID: 12709</p>
<p>    java.lang.NoClassDefFoundError: com.ryg.multidextest.ui.View1</p>
<p>                at com.ryg.multidextest.TestApplication.<init>(TestApplication.java:14)</p>
<p>                at java.lang.Class.newInstanceImpl(Native Method)</p>
<p>                at java.lang.Class.newInstance(Class.java:1208)</p>
<p>                at android.app.Instrumentation.newApplication(Instrumentation.java:990)</p>
<p>                at android.app.Instrumentation.newApplication(Instrumentation.java:975)</p>
<p>                at android.app.LoadedApk.makeApplication(LoadedApk.java:504)</p>
<p>  </p>
<p>Multidex方法虽然很好地解决了方法数越界这个问题，但它也是有一些局限性的，下面是采用multidex可能带来的问题：</p>
<p>（1）应用启动速度会降低。由于应用启动时会加载额外的dex文件，这将导致应用的启动速度降低，甚至可能出现ANR现象，尤其是其他dex文件较大的时候，因此要避免生成较大的dex文件。</p>
<p>（2）由于Dalvik linearAlloc的bug，这可能导致使用multidex的应用无法在Android 4.0以前的手机上运行，因此需要做大量的兼容性测试。同时由于Dalvik linearAlloc的bug，有可能出现应用在运行中由于采用了multidex方案从而产生大量的内存消耗的情况，这会导致应用崩溃。</p>
<p>在实际的项目中，（1）中的现象是客观存在的，但是（2）中的现象目前极少遇到，综合来说，multidex还是一个解决方法数越界非常好的方案，可以在实际项目中使用。</p>
<h2 id="13-3-Android的动态加载技术"><a href="#13-3-Android的动态加载技术" class="headerlink" title="13.3　Android的动态加载技术"></a>13.3　Android的动态加载技术</h2><p>动态加载技术（也叫插件化技术）在技术驱动型的公司中扮演着相当重要的角色，当项目越来越庞大的时候，需要通过插件化来减轻应用的内存和CPU占用，还可以实现热插拔，</p>
<p>即在不发布新版本的情况下更新某些模块。动态加载是一项很复杂的技术，这里主要介绍动态加载技术中的三个基础性问题，至于完整的动态加载技术的实现请参考笔者发起的开源插件化框架DL：<a href="https://github.com/singwhatiwanna/dynamic-load-apk">https://github.com/singwhatiwanna/dynamic-load-apk</a>。项目期间有多位开发人员一起贡献代码。</p>
<p>不同的插件化方案各有各的特色，但是它们都必须要解决三个基础性问题：资源访问、Activity生命周期的管理和ClassLoader的管理。在介绍它们之前，首先要明白宿主和插件的概念，宿主是指普通的apk，而插件一般是指经过处理的dex或者apk，在主流的插件化框架中多采用经过特殊处理的apk来作为插件，处理方式往往和编译以及打包环节有关，另外很多插件化框架都需要用到代理Activity的概念，插件Activity的启动大多数是借助一个代理Activity来实现的。</p>
<ol>
<li>资源访问</li>
</ol>
<p>我们知道，宿主程序调起未安装的插件apk，一个很大的问题就是资源如何访问，具体来说就是插件中凡是以R开头的资源都不能访问了。这是因为宿主程序中并没有插件的资源，所以通过R来加载插件的资源是行不通的，程序会抛出异常：无法找到某某id所对应的资源。针对这个问题，有人提出了将插件中的资源在宿主程序中也预置一份，这虽然能解决问题，但</p>
<p>是这样就会产生一些弊端。首先，这样就需要宿主和插件同时持有一份相同的资源，增加了宿主apk的大小；其次，在这种模式下，每次发布一个插件都需要将资源复制到宿主程序中，这意味着每发布一个插件都要更新一下宿主程序，这就和插件化的思想相违背了。因为插件化的目的就是要减小宿主程序apk包的大小，同时降低宿主程序的更新频率并做到自由装载模块，所以这种方法不可取，它限制了插件的线上更新这一重要特性。还有人提供了另一种方式，首先将插件中的资源解压出来，然后通过文件流去读取资源，这样做理论上是可行的，但是实际操作起来还是有很大难度的。首先不同资源有不同的文件流格式，比如图片、XML等，其次针对不同设备加载的资源可能是不一样的，如何选择合适的资源也是一个需要解决的问题，基于这两点，这种方法也不建议使用，因为它实现起来有较大难度。为了方便地对插件进行资源管理，下面给出一种合理的方式。</p>
<p>我们知道，Activity的工作主要是通过ContextImpl来完成的，Activity中有一个叫mBase的成员变量，它的类型就是ContextImpl。注意到Context中有如下两个抽象方法，看起来是和资源有关的，实际上Context就是通过它们来获取资源的。这两个抽象方法的真正实现在ContextImpl中，也就是说，只要实现这两个方法，就可以解决资源问题了。</p>
<p>&#x2F;** Return an AssetManager instance for your application’s package. *&#x2F;</p>
<p>    public abstract AssetManager getAssets();</p>
<p>     &#x2F;** Return a Resources instance for your application’s package. *&#x2F;</p>
<p>    public abstract Resources getResources();</p>
<p>下面给出具体的实现方式，首先要加载apk中的资源，如下所示。</p>
<p>protected void loadResources() {</p>
<p>        try {</p>
<p>                AssetManager assetManager &#x3D; AssetManager.class.newInstance();</p>
<p>                Method addAssetPath &#x3D; assetManager.getClass().getMethod (“addAssetPath”,String.class);</p>
<p>                addAssetPath.invoke(assetManager,mDexPath);</p>
<p>                mAssetManager &#x3D; assetManager;</p>
<p>        } catch (Exception e) {</p>
<p>                e.printStackTrace();</p>
<p>        }</p>
<p>        Resources superRes &#x3D; super.getResources();</p>
<p>        mResources &#x3D; new Resources(mAssetManager,superRes.getDisplay-Metrics(),</p>
<p>                        superRes.getConfiguration());</p>
<p>        mTheme &#x3D; mResources.newTheme();</p>
<p>        mTheme.setTo(super.getTheme());</p>
<p>    }</p>
<p>从loadResources()的实现可以看出，加载资源的方法是通过反射，通过调用AssetManager中的addAssetPath方法，我们可以将一个apk中的资源加载到Resources对象中，由于addAssetPath是隐藏API我们无法直接调用，所以只能通过反射。下面是它的声明，通过注释我们可以看出，传递的路径可以是zip文件也可以是一个资源目录，而apk就是一个zip，所以直接将apk的路径传给它，资源就加载到AssetManager中了。然后再通过AssetManager来创建一个新的Resources对象，通过这个对象我们就可以访问插件apk中的资源了，这样一来问题就解决了。</p>
<p>&#x2F;**</p>
<p>      * Add an additional set of assets to the asset manager. This can be</p>
<p>      * either a directory or ZIP file. Not for use by applications. Returns</p>
<p>      * the cookie of the added asset,or 0 on failure.</p>
<p>      * {@hide}</p>
<p>      *&#x2F;</p>
<p>    public final int addAssetPath(String path) {</p>
<p>        synchronized (this) {</p>
<p>                int res &#x3D; addAssetPathNative(path);</p>
<p>                makeStringBlocks(mStringBlocks);</p>
<p>                return res;</p>
<p>        }</p>
<p>    }</p>
<p>接着在代理Activity中实现getAssets()和getResources()，如下所示。关于代理Activity的含义请参看DL开源插件化框架的实现细节，这里不再详细描述了。</p>
<p>@Override</p>
<p>    public AssetManager getAsset</p>
<p>s() {</p>
<p>        return mAssetManager &#x3D;&#x3D; null ? super.getAssets() : mAssetManager;</p>
<p>    }</p>
<p>    @Override</p>
<p>    public Resources getResources() {</p>
<p>        return mResources &#x3D;&#x3D; null ? super.getResources() : mResources;</p>
<p>    }</p>
<p>通过上述这两个步骤，就可以通过R来访问插件中的资源了。</p>
<ol start="2">
<li>Activity生命周期的管理</li>
</ol>
<p>管理Activity生命周期的方式各种各样，这里只介绍两种：反射方式和接口方式。反射的方式很好理解，首先通过Java的反射去获取Activity的各种生命周期方法，比如onCreate、onStart、onResume等，然后在代理Activity中去调用插件Activity对应的生命周期方法即可，如下所示。</p>
<p>@Override</p>
<p>    protected void onResume() {</p>
<p>        super.onResume();</p>
<p>        Method onResume &#x3D; mActivityLifecircleMethods.get(“onResume”);</p>
<p>        if (onResume !&#x3D; null) {</p>
<p>                try {</p>
<p>                        onResume.invoke(mRemoteActivity,new Object[] { });</p>
<p>                } catch (Exception e) {</p>
<p>                        e.printStackTrace();</p>
<p>                }</p>
<p>        }</p>
<p>    }</p>
<p>    @Override</p>
<p>    protected void onPause() {</p>
<p>        Method onPause &#x3D; mActivityLifecircleMethods.get(“onPause”);</p>
<p>        if (onPause !&#x3D; null) {</p>
<p>                try {</p>
<p>                        onPause.invoke(mRemoteActivity,new Object[] { });</p>
<p>                } catch (Exception e) {</p>
<p>                        e.printStackTrace();</p>
<p>                }</p>
<p>        }</p>
<p>        super.onPause();</p>
<p>    }</p>
<p>使用反射来管理插件Activity的生命周期是有缺点的，一方面是反射代码写起来比较复杂，另一方面是过多使用反射会有一定的性能开销。下面介绍接口方式，接口方式很好地解决了反射方式的不足之处，这种方式将Activity的生命周期方法提取出来作为一个接口（比如叫DLPlugin），然后通过代理Activity去调用插件Activity的生命周期方法，这样就完成了插件Activity的生命周期管理，并且没有采用反射，这就解决了性能问题。同时接口的声明也比较简单，下面是DLPlugin的声明：</p>
<p>public interface DLPlugin {</p>
<p>         public void onStart();</p>
<p>         public void onRestart();</p>
<p>         public void onActivityResult(int requestCode,int resultCode,Intent data);</p>
<p>         public void onResume();</p>
<p>         public void onPause();</p>
<p>         public void onStop();</p>
<p>         public void onDestroy();</p>
<p>         public void onCreate(Bundle savedInstanceState);</p>
<p>         public void setProxy(Activity proxyActivity,String dexPath);</p>
<p>         public void onSaveInstanceState(Bundle outState);</p>
<p>         public void onNewIntent(Intent intent);</p>
<p>         public void onRestoreInstanceState(Bundle savedInstanceState);</p>
<p>         public boolean onTouchEvent(MotionEvent event);</p>
<p>         public boolean onKeyUp(int keyCode,KeyEvent event);</p>
<p>         public void onWindowAttributesChanged(LayoutParams params);</p>
<p>         public void onWindowFocusChanged(boolean hasFocus);</p>
<p>    public void onBackPressed();</p>
<p>     …</p>
<p>    }</p>
<p>在代理Activity中只需要按如下方式即可调用插件Activity的生命周期方法，这就完成了插件Activity的生命周期的管理。</p>
<p>…</p>
<p>    @Override</p>
<p>    protected void onStart() {</p>
<p>        mRemoteActivity.onStart();</p>
<p>        super.onStart();</p>
<p>    }</p>
<p>    @Override</p>
<p>    protected void onRestart() {</p>
<p>        mRemoteActivity.onRestart();</p>
<p>        super.onRestart();</p>
<p>    }</p>
<p>    @Override</p>
<p>    protected void onResume() {</p>
<p>        mRemoteActivity.onResume();</p>
<p>        super.onResume();</p>
<p>    }</p>
<p>    </p>
<p>通过上述代码应该不难理解接口方式对插件Activity生命周期的管理思想，其中mRemot</p>
<p>eActivity就是DLPlugin的实现。</p>
<ol start="3">
<li>插件ClassLoader的管理</li>
</ol>
<p>为了更好地对多插件进行支持，需要合理地去管理各个插件的DexClassoader，这样同一个插件就可以采用同一个ClassLoader去加载类，从而避免了多个ClassLoader加载同一个类时所引发的类型转换错误。在下面的代码中，通过将不同插件的ClassLoader存储在一个HashMap中，这样就可以保证不同插件中的类彼此互不干扰。</p>
<p>public class DLClassLoader extends DexClassLoader {</p>
<p>         private static final String TAG &#x3D; “DLClassLoader”;</p>
<p>         private static final HashMap&lt;String,DLClassLoader&gt; mPluginClassLoaders</p>
<p>         &#x3D; new HashMap&lt;String,DLClassLoader&gt;();</p>
<p>         protected DLClassLoader(String dexPath,String optimizedDirectory,String libraryPath,ClassLoader parent) {</p>
<p>             super(dexPath,optimizedDirectory,libraryPath,parent);</p>
<p>         }</p>
<p>         &#x2F;**</p>
<p>          * return a available classloader which belongs to different apk</p>
<p>          *&#x2F;</p>
<p>         public static DLClassLoader getClassLoader(String dexPath,Context</p>
<p>         context,ClassLoader parentLoader) {</p>
<p>             DLClassLoader dLClassLoader &#x3D; mPluginClassLoaders.get(dexPath);</p>
<p>             if (dLClassLoader !&#x3D; null)</p>
<p>                 return dLClassLoader;</p>
<p>             File dexOutputDir &#x3D; context.getDir(“dex”,Context.MODE_PRIVATE);</p>
<p>             final String dexOutputPath &#x3D; dexOutputDir.getAbsolutePath();</p>
<p>             dLClassLoader &#x3D; new DLClassLoader(dexPath,dexOutputPath,null,</p>
<p>             parentLoader);</p>
<p>             mPluginClassLoaders.put(dexPath,dLClassLoader);</p>
<p>             return dLClassLoader;</p>
<p>         }</p>
<p>    }</p>
<p>事实上插件化的技术细节非常多，这绝非一个章节的内容所能描述清楚的，另外插件化作为一种核心技术，需要开发者有较深的开发功底才能够很好地理解，因此本节的内容更多是让读者对插件化开发有一个感性的了解，细节上还需要读者自己去钻研，也可以通过DL插件化框架去深入地学习。</p>
<h2 id="13-4-反编译初步"><a href="#13-4-反编译初步" class="headerlink" title="13.4　反编译初步"></a>13.4　反编译初步</h2><p>反编译属于逆向工程中的一种，反编译有很多高级的手段和工具，本节只是为了让读者掌握初级的反编译手段，毕竟对于一个不是专业做逆向的开发人员来说，的确没有必要花大量时间去研究反编译的一些高级技巧。本节主要介绍两方面的内容，一方面是介绍使用dex2jar和jd-gui来反编译apk的方式，另一方面是介绍使用apktool来对apk进行二次打包的方式。下面是这三个反编译工具的下载地址。</p>
<p>apktool：<a target="_blank" rel="noopener" href="http://ibotpeaches.github.io/Apktool/">http://ibotpeaches.github.io/Apktool/</a></p>
<p>dex2jar：<a href="https://github.com/pxb1988/dex2jar">https://github.com/pxb1988/dex2jar</a></p>
<p>jd-gui：<a target="_blank" rel="noopener" href="http://jd.benow.ca/">http://jd.benow.ca/</a></p>
<h3 id="13-4-1-使用dex2jar和jd-gui反编译apk"><a href="#13-4-1-使用dex2jar和jd-gui反编译apk" class="headerlink" title="13.4.1　使用dex2jar和jd-gui反编译apk"></a>13.4.1　使用dex2jar和jd-gui反编译apk</h3><p>Dex2jar和jd-gui在很多操作系统上都可以使用，本节只介绍它们在Windows和Linux上的使用方式。Dex2jar是一个将dex文件转换为jar包的工具，它在Windows和Linux上都有对应的版本，dex文件来源于apk，将apk通过zip包的方式解压缩即可提取出里面的dex文件。有了jar包还不行，因为jar包中都是class文件，这个时候还需要jd-gui将jar包进一步转换为Java代码，jd-gui仍然支持Windows和Linux，不管是dex2jar还是jd-gui，它们在不同的操作系统中的使用方式都是一致的。</p>
<p>Dex2jar是命令行工具，它的使用方式如下：</p>
<p>Linux (Ubuntu)：.&#x2F;dex2jar.sh classes.dex</p>
<p>Windows：dex2jar.bat classes.dex</p>
<p>Jd-gui是图形化工具，直接双击打开后通过菜单打开jar包即可查看jar包的源码。下面做一个示例，通过dex2jar和jd-gui来反编译13.1节中的示例程序的apk。首先将apk解压后提取出classes.dex文件，接着通过dex2jar反编译classes.dex，然后通过jd-gui来打开反编译后的jar包，如图13-3所示。可以发现反编译后的结果和第13.1节中CrashActivity的源代码已经比较接近了，通过左边的菜单可以查看其他类的反编译结果。</p>
<p>图13-3　使用jd-gui反编译jar包</p>
<h3 id="13-4-2-使用apktool对apk进行二次打包"><a href="#13-4-2-使用apktool对apk进行二次打包" class="headerlink" title="13.4.2　使用apktool对apk进行二次打包"></a>13.4.2　使用apktool对apk进行二次打包</h3><p>在13.4.1节中介绍了dex2jar和jd-gui的使用方式，通过它们可以将一个dex文件反编译为Java代码，但是它们无法反编译出apk中的二进制数据资源，但是采用apktool就可以做到这一点。apktool另外一个常见的用途是二次打包，也就是常见的山寨版应用。将官方应用二次打包为山寨应用，这是一种不被提倡的行为，甚至是违法的，建议开发者不要去这么做，但是掌握以下二次打包的技术对于个人技术的提高还是很有意义的。apktool同样有多个版本，这里同样只介绍Windows版和Linux版，apktool是一个命令行工具，它的使用方式如下所示。这里仍然拿13.1节中的示例程序为例，假定apk的文件名为CrashTest.apk。</p>
<p>Linux （Ubuntu）</p>
<p>解包：.&#x2F;apktool d -f CrashTest.apk CrashTest。</p>
<p>二次打包：.&#x2F;apktool b CrashTest CrashTest-fake.apk。</p>
<p>签名：java -jar signapk.jar testkey.x509.pem testkey.pk8 CrashTest-fake.apk CrashTest-fake-signed.apk。</p>
<p>Windows</p>
<p>解包：apktool.bat d -f CrashTest.apk CrashTest。</p>
<p>二次打包：apktool.bat b CrashTest CrashTest-fake.apk。</p>
<p>签名：java -jar signapk.jar testkey.x509.pem testkey.pk8 CrashTest-fake.apk CrashTest-fake-signed.apk。</p>
<p>需要注意的是，由于Windows系统的兼容性问题，有时候会导致apktool.bat无法在Windows的一些版本上正常工作，比如Windows 8，这个时候可以安装Cygwin，然后采用Linux的方式来进行打包即可。除此之外，部分apk也可能会打包失败，以笔者的个人经验来说，apktool在Linux上的打包成功率要比Windows高。</p>
<p>这里对上面的二次打包的命令稍作解释，解包命令中，d表示解包，CrashTest.apk表示待解包的apk，CrashTest表示解包后的文件的存储路径，-f表示如果CrashTest目录已经存在，那么直接覆盖它。</p>
<p>打包命令中，b表示打包，CrashTest表示解包后的文件的存储路径，CrashTest-fake.apk表示二次打包后的文件名。通过apktool解包以后，可以查看到apk中的资源以及smali文件，smali文件是dex文件反编译（不同于dex2jar的反编译过程）的结果。smali有自己的语法并且可以修改，修改后可以被二次打包为apk，通过这种方式就可以修改apk的执行逻辑，显然这让山寨应用变得十分危险。需要注意的是，apk经过二次打包后并不能直接安装，必须要经过签名后才能安装。</p>
<p>签名命令中，采用signapk.jar来完成签名，签名后生成的apk就是一个山寨版的apk，因为签名过程中所采用的签名文件不是官方的，最终CrashTest-fake-signed.apk就是二次打包形成的一个山寨版的apk。对于本文中的例子来说，CrashTest-fake-signed.apk安装后其功能和正版的CrashTest.apk是没有区别的。</p>
<p>在实际开发中，很多产品都会做签名校验，简单的二次打包所得到的山寨版apk安装后无法运行。尽管如此，还是可以通过修改smali的方式来绕过签名校验，这就是为什么市面上仍然有那么多的山寨版应用的原因。一般来说山寨版应用都具有一定的危害性，我们要抵制山寨版应用以防止自己的财产遭受到损失。关于smali的语法以及如何修改smali，这就属于比较深入的话题了，本节不再对它们进行深入的介绍，感兴趣的话可以阅读逆向方面的专业书籍，也可以阅读笔者之前写的一篇介绍应用破解的文章：</p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/singwhatiwanna/article/details/18797493">http://blog.csdn.net/singwhatiwanna/article/details/18797493</a>。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/android/">android</a></div><div class="post_share"><div class="social-share" data-image="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2Fd5f80e1a-f4c1-4f5c-aad2-fe213ae89f64%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&amp;refer=http%3A%2F%2Fsafe-img.xhscdn.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1710160772&amp;t=4038984b7822fc46c9a8d50e0c5106b4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/01/12/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC12%E7%AB%A0%20Bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8CCache/" title="第十二章　Bitmap的加载和Cache"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第十二章　Bitmap的加载和Cache</div></div></a></div><div class="next-post pull-right"><a href="/2021/01/14/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC14%E7%AB%A0%20JNI%E5%92%8CNDK%E7%BC%96%E7%A8%8B/" title="第十四章 JNI和NDK编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第十四章 JNI和NDK编程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/01/10/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC10%E7%AB%A0%20Android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/" title="第十章　Android的消息机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-10</div><div class="title">第十章　Android的消息机制</div></div></a></div><div><a href="/2021/01/11/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC11%E7%AB%A0%20Android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="第十一章　Android的线程和线程池"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-11</div><div class="title">第十一章　Android的线程和线程池</div></div></a></div><div><a href="/2021/01/14/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC14%E7%AB%A0%20JNI%E5%92%8CNDK%E7%BC%96%E7%A8%8B/" title="第十四章 JNI和NDK编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-14</div><div class="title">第十四章 JNI和NDK编程</div></div></a></div><div><a href="/2021/01/12/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC12%E7%AB%A0%20Bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8CCache/" title="第十二章　Bitmap的加载和Cache"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-12</div><div class="title">第十二章　Bitmap的加载和Cache</div></div></a></div><div><a href="/2021/01/15/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC15%E7%AB%A0%20Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="第十五章 Android性能优化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-15</div><div class="title">第十五章 Android性能优化</div></div></a></div><div><a href="/2021/01/04/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC4%E7%AB%A0%20View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" title="第四章　View的工作原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-04</div><div class="title">第四章　View的工作原理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2Fd5f80e1a-f4c1-4f5c-aad2-fe213ae89f64%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&amp;refer=http%3A%2F%2Fsafe-img.xhscdn.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1710160772&amp;t=4038984b7822fc46c9a8d50e0c5106b4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Junyong Tu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" href="https://github.com/juncaixingchi1993"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-%E4%BD%BF%E7%94%A8CrashHandler%E6%9D%A5%E8%8E%B7%E5%8F%96%E5%BA%94%E7%94%A8%E7%9A%84crash%E4%BF%A1%E6%81%AF"><span class="toc-number">1.</span> <span class="toc-text">13.1　使用CrashHandler来获取应用的crash信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-%E4%BD%BF%E7%94%A8multidex%E6%9D%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E6%95%B0%E8%B6%8A%E7%95%8C"><span class="toc-number">2.</span> <span class="toc-text">13.2　使用multidex来解决方法数越界</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3-Android%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E6%8A%80%E6%9C%AF"><span class="toc-number">3.</span> <span class="toc-text">13.3　Android的动态加载技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-4-%E5%8F%8D%E7%BC%96%E8%AF%91%E5%88%9D%E6%AD%A5"><span class="toc-number">4.</span> <span class="toc-text">13.4　反编译初步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-1-%E4%BD%BF%E7%94%A8dex2jar%E5%92%8Cjd-gui%E5%8F%8D%E7%BC%96%E8%AF%91apk"><span class="toc-number">4.1.</span> <span class="toc-text">13.4.1　使用dex2jar和jd-gui反编译apk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-2-%E4%BD%BF%E7%94%A8apktool%E5%AF%B9apk%E8%BF%9B%E8%A1%8C%E4%BA%8C%E6%AC%A1%E6%89%93%E5%8C%85"><span class="toc-number">4.2.</span> <span class="toc-text">13.4.2　使用apktool对apk进行二次打包</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/01/15/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC15%E7%AB%A0%20Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="第十五章 Android性能优化">第十五章 Android性能优化</a><time datetime="2021-01-15T14:07:08.000Z" title="发表于 2021-01-15 22:07:08">2021-01-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/01/14/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC14%E7%AB%A0%20JNI%E5%92%8CNDK%E7%BC%96%E7%A8%8B/" title="第十四章 JNI和NDK编程">第十四章 JNI和NDK编程</a><time datetime="2021-01-14T14:07:08.000Z" title="发表于 2021-01-14 22:07:08">2021-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/01/13/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC13%E7%AB%A0%20%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/" title="第十三章 综合技术">第十三章 综合技术</a><time datetime="2021-01-13T14:07:08.000Z" title="发表于 2021-01-13 22:07:08">2021-01-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/01/12/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC12%E7%AB%A0%20Bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8CCache/" title="第十二章　Bitmap的加载和Cache">第十二章　Bitmap的加载和Cache</a><time datetime="2021-01-12T14:07:08.000Z" title="发表于 2021-01-12 22:07:08">2021-01-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/01/11/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC11%E7%AB%A0%20Android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="第十一章　Android的线程和线程池">第十一章　Android的线程和线程池</a><time datetime="2021-01-11T14:07:08.000Z" title="发表于 2021-01-11 22:07:08">2021-01-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Junyong Tu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>