<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>第十一章　Android的线程和线程池 | Junyong Tu の 杂记</title><meta name="author" content="Junyong Tu"><meta name="copyright" content="Junyong Tu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本章的主题是Android中的线程和线程池。线程在Android中是一个很重要的概念，从用途上来说，线程分为主线程和子线程，主线程主要处理和界面相关的事情，而子线程则往往用于执行耗时操作。由于Android的特性，如果在主线程中执行耗时操作那么就会导致程序无法及时地响应，因此耗时操作必须放在子线程中去执行。除了Thread本身以外，在Android中可以扮演线程角色的还有很多，比如AsyncTas">
<meta property="og:type" content="article">
<meta property="og:title" content="第十一章　Android的线程和线程池">
<meta property="og:url" content="https://github.com/juncaixingchi1993/juncaixingchi1993.github.io/2021/01/11/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC11%E7%AB%A0%20Android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/index.html">
<meta property="og:site_name" content="Junyong Tu の 杂记">
<meta property="og:description" content="本章的主题是Android中的线程和线程池。线程在Android中是一个很重要的概念，从用途上来说，线程分为主线程和子线程，主线程主要处理和界面相关的事情，而子线程则往往用于执行耗时操作。由于Android的特性，如果在主线程中执行耗时操作那么就会导致程序无法及时地响应，因此耗时操作必须放在子线程中去执行。除了Thread本身以外，在Android中可以扮演线程角色的还有很多，比如AsyncTas">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2Fd5f80e1a-f4c1-4f5c-aad2-fe213ae89f64%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1710160772&t=4038984b7822fc46c9a8d50e0c5106b4">
<meta property="article:published_time" content="2021-01-11T14:07:08.000Z">
<meta property="article:modified_time" content="2024-02-14T11:20:52.505Z">
<meta property="article:author" content="Junyong Tu">
<meta property="article:tag" content="android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2Fd5f80e1a-f4c1-4f5c-aad2-fe213ae89f64%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1710160772&t=4038984b7822fc46c9a8d50e0c5106b4"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://github.com/juncaixingchi1993/juncaixingchi1993.github.io/2021/01/11/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC11%E7%AB%A0%20Android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第十一章　Android的线程和线程池',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-14 19:20:52'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2Fd5f80e1a-f4c1-4f5c-aad2-fe213ae89f64%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&amp;refer=http%3A%2F%2Fsafe-img.xhscdn.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1710160772&amp;t=4038984b7822fc46c9a8d50e0c5106b4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img2.baidu.com/it/u=1361506290,4036378790&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500')"><nav id="nav"><span id="blog-info"><a href="/" title="Junyong Tu の 杂记"><span class="site-name">Junyong Tu の 杂记</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 图片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第十一章　Android的线程和线程池</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-11T14:07:08.000Z" title="发表于 2021-01-11 22:07:08">2021-01-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-14T11:20:52.505Z" title="更新于 2024-02-14 19:20:52">2024-02-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/">艺术探索</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="第十一章　Android的线程和线程池"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本章的主题是Android中的线程和线程池。线程在Android中是一个很重要的概念，从用途上来说，线程分为主线程和子线程，主线程主要处理和界面相关的事情，而子线程则往往用于执行耗时操作。由于Android的特性，如果在主线程中执行耗时操作那么就会导致程序无法及时地响应，因此耗时操作必须放在子线程中去执行。除了Thread本身以外，在Android中可以扮演线程角色的还有很多，比如AsyncTask和IntentService，同时HandlerThread也是一种特殊的线程。尽管AsyncTask、IntentService以及HandlerThread的表现形式都有别于传统的线程，但是它们的本质仍然是传统的线程。对于AsyncTask来说，它的底层用到了线程池，对于IntentService和HandlerThread来说，它们的底层则直接使用了线程。</p>
<p>不同形式的线程虽然都是线程，但是它们仍然具有不同的特性和使用场景。AsyncTask封装了线程池和Handler，它主要是为了方便开发者在子线程中更新UI。HandlerThread是一种具有消息循环的线程，在它的内部可以使用Handler。IntentService是一个服务，系统对其进行了封装使其可以更方便地执行后台任务，IntentService内部采用HandlerThread来执行任务，当任务执行完毕后IntentService会自动退</p>
<p>出。从任务执行的角度来看，IntentService的作用很像一个后台线程，但是IntentService是一种服务，它不容易被系统杀死从而可以尽量保证任务的执行，而如果是一个后台线程，由于这个时候进程中没有活动的四大组件，那么这个进程的优先级就会非常低，会很容易被系统杀死，这就是IntentService的优点。</p>
<p>在操作系统中，线程是操作系统调度的最小单元，同时线程又是一种受限的系统资源，即线程不可能无限制地产生，并且线程的创建和销毁都会有相应的开销。当系统中存在大量的线程时，系统会通过时间片轮转的方式调度每个线程，因此线程不可能做到绝对的并行，除非线程数量小于等于CPU的核心数，一般来说这是不可能的。试想一下，如果在一个进程中频繁地创建和销毁线程，这显然不是高效的做法。正确的做法是采用线程池，一个线程池中会缓存一定数量的线程，通过线程池就可以避免因为频繁创建和销毁线程所带来的系统开销。Android中的线程池来源于Java，主要是通过Executor来派生特定类型的线程池，不同种类的线程池又具有各自的特性，详细内容会在11.3节中进行介绍。</p>
<h2 id="11-1-主线程和子线程"><a href="#11-1-主线程和子线程" class="headerlink" title="11.1　主线程和子线程"></a>11.1　主线程和子线程</h2><p>主线程是指进程所拥有的线程，在Java中默认情况下一个进程只有一个线程，这个线程就是主线程。主线程主要处理界面交互相关的</p>
<p>逻辑，因为用户随时会和界面发生交互，因此主线程在任何时候都必须有较高的响应速度，否则就会产生一种界面卡顿的感觉。为了保持较高的响应速度，这就要求主线程中不能执行耗时的任务，这个时候子线程就派上用场了。子线程也叫工作线程，除了主线程以外的线程都是子线程。</p>
<p>Android沿用了Java的线程模型，其中的线程也分为主线程和子线程，其中主线程也叫UI线程。主线程的作用是运行四大组件以及处理它们和用户的交互，而子线程的作用则是执行耗时任务，比如网络请求、I&#x2F;O操作等。从Android 3.0开始系统要求网络访问必须在子线程中进行，否则网络访问将会失败并抛出NetworkOnMainThreadException这个异常，这样做是为了避免主线程由于被耗时操作所阻塞从而出现ANR现象。</p>
<h2 id="11-2-Android中的线程形态"><a href="#11-2-Android中的线程形态" class="headerlink" title="11.2　Android中的线程形态"></a>11.2　Android中的线程形态</h2><p>本节将对Android中的线程形态做一个全面的介绍，除了传统的Thread以外，还包含AsyncTask、HandlerThread以及IntentService，这三者的底层实现也是线程，但是它们具有特殊的表现形式，同时在使用上也各有优缺点。为了简化在子线程中访问UI的过程，系统提供了AsyncTask，AsyncTask经过几次修改，导致了对于不同的API版本AsyncTask具有不同的表现，尤其是多任务的并发执行上。由于这个原因</p>
<p>，很多开发者对AsyncTask的使用上存在误区，本节将详细介绍使用AsyncTask时的注意事项，并从源码的角度来分析AsyncTask的执行过程。</p>
<h3 id="11-2-1-AsyncTask"><a href="#11-2-1-AsyncTask" class="headerlink" title="11.2.1　AsyncTask"></a>11.2.1　AsyncTask</h3><p>AsyncTask是一种轻量级的异步任务类，它可以在线程池中执行后台任务，然后把执行的进度和最终结果传递给主线程并在主线程中更新UI。从实现上来说，AsyncTask封装了Thread和Handler，通过AsyncTask可以更加方便地执行后台任务以及在主线程中访问UI，但是AsyncTask并不适合进行特别耗时的后台任务，对于特别耗时的任务来说，建议使用线程池。</p>
<p>AsyncTask是一个抽象的泛型类，它提供了Params、Progress和Result这三个泛型参数，其中Params表示参数的类型，Progress表示后台任务的执行进度的类型，而Result则表示后台任务的返回结果的类型，如果AsyncTask确实不需要传递具体的参数，那么这三个泛型参数可以用Void来代替。AsyncTask这个类的声明如下所示。</p>
<p>public abstract class AsyncTask&lt;Params,Progress,Result&gt;。</p>
<p>AsyncTask提供了4个核心方法，它们的含义如下所示。</p>
<p>（1）onPreExecute()，在主线程中执行，在异步任务执行之前，此方法会被调用，一般</p>
<p>可以用于做一些准备工作。</p>
<p>（2）doInBackground(Params…params)，在线程池中执行，此方法用于执行异步任务，params参数表示异步任务的输入参数。在此方法中可以通过publishProgress方法来更新任务的进度，publishProgress方法会调用onProgressUpdate方法。另外此方法需要返回计算结果给onPostExecute方法。</p>
<p>（3）onProgressUpdate(Progress…values)，在主线程中执行，当后台任务的执行进度发生改变时此方法会被调用。</p>
<p>（4）onPostExecute(Result result)，在主线程中执行，在异步任务执行之后，此方法会被调用，其中result参数是后台任务的返回值，即doInBackground的返回值。</p>
<p>上面这几个方法，onPreExecute先执行，接着是doInBackground，最后才是onPostExecute。除了上述四个方法以外，AsyncTask还提供了onCancelled()方法，它同样在主线程中执行，当异步任务被取消时，onCancelled()方法会被调用，这个时候onPostExecute则不会被调用。下面提供一个典型的示例，如下所示。</p>
<p>private class DownloadFilesTask extends AsyncTask&lt;URL,Integer,Long&gt; {</p>
<p>        protected Long doInBackground(URL… urls) {</p>
<p>                int count &#x3D; urls.length;</p>
<p>   </p>
<p>long totalSize &#x3D; 0;</p>
<p>                for (int i &#x3D; 0; i &lt; count; i++) {</p>
<p>                        totalSize +&#x3D; Downloader.downloadFile(urls[i]);</p>
<p>                        publishProgress((int) ((i &#x2F; (float) count) * 100));</p>
<p>                        &#x2F;&#x2F; Escape early if cancel() is called</p>
<p>                        if (isCancelled())</p>
<p>                                break;</p>
<p>                }</p>
<p>                return totalSize;</p>
<p>        }</p>
<p>        protected void onProgressUpdate(Integer… progress) {</p>
<p>                setProgressPercent(progress[0]);</p>
<p>        }</p>
<p>        protected void onPostExecute(Long result) {</p>
<p>                showDialog(“Downloaded “ + result + “ bytes”);</p>
<p>        }</p>
<p>    }</p>
<p>在上面的代码中，实现了一个具体的AsyncTask类，这个类主要用于模拟文件的下载过程，它的输入参数类型为URL，后台任务的进程参数为Integer，而后台任务的返回结果为Long类型。注意到doInBackground和onProgressUpdate方法它们的参数中均包含…的字样，在Java中…表示参数的数量不定，它是一种数组型参数，…的概念和C语言中的…是一致的。当要执行上述下载任务时，可以通过如下方式来完成：</p>
<p>new DownloadFilesTask().execute(url1,url2,url3);</p>
<p>在DownloadFilesTask中，doInBackground用来执行具体的下载任务并通过publishProgress方法来更新下载的进度，同时还要判断下载任务是否被外界取消了。当下载任务完成后，doInBackground会返回结果，即下载的总字节数。需要注意的是，doInBackground是在线程池中执行的。onProgressUpdate用于更新界面中下载的进度，它运行在主线程，当publishProgress被调用时，此方法就会被调用。当下载任务完成后，onPostExecute方法就会被调用，它也是运行在主线程中，这个时候我们就可以在界面上做出一些提示，比如弹出一个对话框告知用户下载已经完成。</p>
<p>AsyncTask在具体的使用过程中也是有一些条件限制的，主要有如下几点：</p>
<p>（1）AsyncTask的类必须在主线程中加载，这就意味着第一次访问AsyncTask必须发生在主线程，当然这个过程在Android 4.1及以上版本中已经被系统自动完成。在Android 5.0的源码中，可以查看ActivityThread的main方法，它会调用AsyncTask的init方法，这就满足了AsyncTask的类必须在主线程中进行加载这个条件了。至于为什么必须要满足这个条件，在11.2.2节中会结合AsyncTask的源码再次分析这个问题。</p>
<p>（2）AsyncTask的对象必须在主线程中创建。</p>
<p>（3）execute方法必须在UI线程调用。</p>
<p>（4）不要在程序中直接调用onPreExecute()、onPostExecute、doInBackground和onProgressUpdate方法。</p>
<p>（5）一个AsyncTask对象只能执行一次，即只能调用一次execute方法，否则会报运行时异常。</p>
<p>（6）在Android 1.6之前，AsyncTask是串行执行任务的，Android 1.6的时候AsyncTask开始采用线程池里处理并行任务，但是从Android 3.0开始，为了避免AsyncTask所带来的并发错误，AsyncTask又采用一个线程来串行执行任务。尽管如此，在Android 3.0以及后续的版本中，我们仍然可以通过AsyncTask的executeOnExecutor方法来并行地执行任务。</p>
<h3 id="11-2-2-AsyncTask的工作原理"><a href="#11-2-2-AsyncTask的工作原理" class="headerlink" title="11.2.2　AsyncTask的工作原理"></a>11.2.2　AsyncTask的工作原理</h3><p>为了分析AsyncTask的工作原理，我们从它的execute方法开始分析，execute方法又会调用executeOnExecutor方法，它们的实现如下所示。</p>
<p>public final AsyncTask&lt;Params,Progress,Result&gt; execute(Params… params) {</p>
<p>        return executeOnExecutor(sDefaultExecutor,params);</p>
<p>    }</p>
<p>    public final AsyncTask&lt;</p>
<p>Params,Progress,Result&gt; executeOnExecutor(Executor  exec,</p>
<p>                Params… params) {</p>
<p>        if (mStatus !&#x3D; Status.PENDING) {</p>
<p>                switch (mStatus) {</p>
<p>                        case RUNNING:</p>
<p>                                throw new IllegalStateException(“Cannot execute task:”</p>
<p>                                                + “ the task is already running.”);</p>
<p>                        case FINISHED:</p>
<p>                                throw new IllegalStateException(“Cannot execute task:”</p>
<p>                                                + “ the task has already been executed “</p>
<p>                                                + “(a task can be executed only once)”);</p>
<p>                }</p>
<p>        }</p>
<p>        mStatus &#x3D; Status.RUNNING;</p>
<p>        onPreExecute();</p>
<p>        mWorker.mParams &#x3D; params;</p>
<p>        exec.execute(mFuture);</p>
<p>        return this;</p>
<p>    }</p>
<p>在上面的代码中，sDefaultExecutor实际上是一个串行的线程池，一个进程中所有的AsyncTask全部在这个串行的线程池中排队执行，这个排队执行的过程后面会再进行分析。在executeOnExecutor方法中，AsyncTask的onPreExecute方法最先执行，然后线程池开始执行。下面分析线程池的执行过程，如下所示。</p>
<p>public static final Executor SERIAL_EXECUTOR &#x3D; new SerialExecutor();</p>
<p>    private static volatile Executor sDefaultExecutor &#x3D; SERIAL_EXECUTOR;</p>
<p>    private static class SerialExecutor implements Executor {</p>
<p>        final ArrayDeque<Runnable> mTasks &#x3D; new ArrayDeque<Runnable>();</p>
<p>        Runnable mActive;</p>
<p>        public synchronized void execute(final Runnable r) {</p>
<p>                mTasks.offer(new Runnable() {</p>
<p>                        public void run() {</p>
<p>                                try {</p>
<p>                                        r.run();</p>
<p>                                } finally {</p>
<p>                                        scheduleNext();</p>
<p>                                }</p>
<p>                        }</p>
<p>      });</p>
<p>                if (mActive &#x3D;&#x3D; null) {</p>
<p>                        scheduleNext();</p>
<p>                }</p>
<p>        }</p>
<p>        protected synchronized void scheduleNext() {</p>
<p>                if ((mActive &#x3D; mTasks.poll()) !&#x3D; null) {</p>
<p>                        THREAD_POOL_EXECUTOR.execute(mActive);</p>
<p>                }</p>
<p>        }</p>
<p>    }</p>
<p>从SerialExecutor的实现可以分析AsyncTask的排队执行的过程。首先系统会把AsyncTask的Params参数封装为FutureTask对象，Future</p>
<p>Task是一个并发类，在这里它充当了Runnable的作用。接着这个FutureTask会交给SerialExecutor的execute方法去处理，SerialExecutor的execute方法首先会把FutureTask对象插入到任务队列mTasks中，如果这个时候没有正在活动的AsyncTask任务，那么就会调用SerialExecutor的scheduleNext方法来执行下一个AsyncTask任务。同时当一个AsyncTask任务执行完后，AsyncTask会继续执行其他任务直到所有的任务都被执行为止，从这一点可以看出，在默认情况下，AsyncTask是串行执行的。</p>
<p>AsyncTask中有两个线程池（SerialExecutor和THREAD_POOL_EXECUTOR）和一个Handler（InternalHandler），其中线程池SerialExecutor用于任务的排队，而线程池THREAD_POOL_EXECUTOR用于真正地执行任务，InternalHandler用于将执行环境从线程池切换到主线程，关于线程池的概念将在第11.3节中详细介绍，其本质仍然是线程的调用过程。在AsyncTask的构造方法中有如下这么一段代码，由于FutureTask的run方法会调用mWorker的call方法，因此mWorker的call方法最终会在线程池中执行。</p>
<p>mWorker &#x3D; new WorkerRunnable&lt;Params,Result&gt;() {</p>
<p>        public Result call() throws Exception {</p>
<p>                mTaskInvoked.set(true);</p>
<p>                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</p>
<p>                &#x2F;&#x2F;noinspection unc</p>
<p>hecked</p>
<p>                return postResult(doInBackground(mParams));</p>
<p>        }</p>
<p>    };</p>
<p>在mWorker的call方法中，首先将mTaskInvoked设为true，表示当前任务已经被调用过了，然后执行AsyncTask的doInBackground方法，接着将其返回值传递给postResult方法，它的实现如下所示。</p>
<p>private Result postResult(Result result) {</p>
<p>        @SuppressWarnings(“unchecked”)</p>
<p>        Message message &#x3D; sHandler.obtainMessage(MESSAGE_POST_RESULT,new AsyncTaskResult<Result>(this,result));</p>
<p>        message.sendToTarget();</p>
<p>        return result;</p>
<p>    }</p>
<p>在上面的代码中，postResult方法会通过sHandler发送一个MESSAGE_POST_RESULT的消息，这个sHandler的定义如下所示。</p>
<p>private static final InternalHandler sHandler &#x3D; new InternalHandler();</p>
<p>    private static class InternalHandler extends Handler {</p>
<p>        @SuppressWarnings({“unchecked”,”RawUseOfParameterizedType”})</p>
<p>        @Override</p>
<p>        public void handleMessage(Message msg) {</p>
<p>                AsyncTaskResult result &#x3D; (AsyncTaskResult) msg.obj;</p>
<p>可以发现，sHandler是一个静态的Handler</p>
<p>对象，为了能够将执行环境切换到主线程，这就要求sHandler这个对象必须在主线程中创建。由于静态成员会在加载类的时候进行初始化，因此这就变相要求AsyncTask的类必须在主线程中加载，否则同一个进程中的AsyncTask都将无法正常工作。sHandler收到MESSAGE_POST_RESULT这个消息后会调用AsyncTask的finish方法，如下所示。</p>
<p>private void finish(Result result) {</p>
<p>        if (isCancelled()) {</p>
<p>                onCancelled(result);</p>
<p>        } else {</p>
<p>                onPostExecute(result);</p>
<p>        }</p>
<p>        mStatus &#x3D; Status.FINISHED;</p>
<p>    }</p>
<p>AsyncTask的finish方法的逻辑比较简单，如果AsyncTask被取消执行了，那么就调用onCancelled方法，否则就会调用onPostExecute方法，可以看到doInBackground的返回结果会传递给onPostExecute方法，到这里AsyncTask的整个工作过程就分析完毕了。</p>
<p>通过分析AsyncTask的源码，可以进一步确定，从Android 3.0开始，默认情况下AsyncTask的确是串行执行的，在这里通过一系列实验来证实这个判断。</p>
<p>请看如下实验代码，代码很简单，就是单击按钮的时候同时执行5个AsyncTask任务，每个AsyncTask会休眠3s来模拟耗时操作，同时把</p>
<p>每个AsyncTask执行结束的时间打印出来，这样我们就能观察出AsyncTask到底是串行执行还是并行执行。</p>
<p>@Override</p>
<p>    public void onClick(View v) {</p>
<p>        if (v &#x3D;&#x3D; mButton) {</p>
<p>                new MyAsyncTask(“AsyncTask#1”).execute(“”);</p>
<p>                new MyAsyncTask(“AsyncTask#2”).execute(“”);</p>
<p>                new MyAsyncTask(“AsyncTask#3”).execute(“”);</p>
<p>                new MyAsyncTask(“AsyncTask#4”).execute(“”);</p>
<p>                new MyAsyncTask(“AsyncTask#5”).execute(“”);</p>
<p>        }</p>
<p>    }</p>
<p>    private static class MyAsyncTask extends AsyncTask&lt;String,Integer,String&gt; {</p>
<p>        private String mName &#x3D; “AsyncTask”;</p>
<p>        public MyAsyncTask(String name) {</p>
<p>                super();</p>
<p>                mName &#x3D; name;</p>
<p>        }</p>
<p>        @Override</p>
<p>        protected String doInBackground(String… params) {</p>
<p>                try {</p>
<p>                        Thread.sleep(3000);</p>
<p>                } catch (InterruptedException e) {</p>
<p>                        e.printStackTrace();</p>
<p>                }</p>
<p>                return mName;</p>
<p>        }</p>
<p>        @Override</p>
<p>        protected void onPostExecute(String result) {</p>
<p>                super.onPostExecute(result);</p>
<p>     </p>
<p>SimpleDateFormat df &#x3D; new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);</p>
<p>                Log.e(TAG,result + “execute finish at “ + df.format(new Date()));</p>
<p>        }</p>
<p>    }</p>
<p>分别在Android 4.1.1和Android 2.3.3的设备上运行程序，按照本节前面的描述，AsyncTask在4.1.1上应该是串行的，在2.3.3上应该是并行的，到底是不是这样呢？请看下面的运行结果。</p>
<p>Android 4.1.1上执行：如图11-1所示，5个AsyncTask共耗时15s且时间间隔为3s，很显然是串行执行的。</p>
<p>图11-1　AsyncTask在Android 4.1.1上的执行顺序</p>
<p>Android 2.3.3上执行：如图11-2所示，5个AsyncTask的结束时间是一样的，很显然是并行执行的。</p>
<p>图11-2　AsyncTask在Android 2.3.3上的</p>
<p>执行顺序</p>
<p>为了让AsyncTask可以在Android 3.0及以上的版本上并行，可以采用AsyncTask的executeOnExecutor方法，需要注意的是这个方法是Android 3.0新添加的方法，并不能在低版本上使用，如下所示。</p>
<p>@TargetApi(Build.VERSION_CODES.HONEYCOMB)</p>
<p>    @Override</p>
<p>    public void onClick(View v) {</p>
<p>        if (v &#x3D;&#x3D; mButton) {</p>
<p>                if (Build.VERSION.SDK_INT &#x3D;&gt; Build.VERSION_CODES.HONEYCOMB) {</p>
<p>                        new MyAsyncTask(“AsyncTask#1”).</p>
<p>    executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,””);</p>
<p>                        new MyAsyncTask(“AsyncTask#2”).</p>
<p>    executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,””);</p>
<p>                        new MyAsyncTask(“AsyncTask#3”).</p>
<p>    executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,””);</p>
<p>                        new MyAsyncTask(“AsyncTask#4”).</p>
<p>    executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,””);</p>
<p>                        new MyAsyncTask(“AsyncTask#5”).</p>
<p>    executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,””);</p>
<p>                }</p>
<p>        }</p>
<p>    }</p>
<p>    private static class MyAsyncTask extends AsyncTask&lt;String,Integer,String&gt;</p>
<p>{</p>
<p>        private String mName &#x3D; “AsyncTask”;</p>
<p>        public MyAsyncTask(String name) {</p>
<p>                super();</p>
<p>                mName &#x3D; name;</p>
<p>        }</p>
<p>        @Override</p>
<p>        protected String doInBackground(String… params) {</p>
<p>                try {</p>
<p>                        Thread.sleep(3000);</p>
<p>                } catch (InterruptedException e) {</p>
<p>                        e.printStackTrace();</p>
<p>                }</p>
<p>                return mName;</p>
<p>        }</p>
<p>        @Override</p>
<p>        protected void onPostExecute(String result) {</p>
<p>                super.onPostExecute(result);</p>
<p>                SimpleDateFormat df &#x3D; new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);</p>
<p>                Log.e(TAG,result + “execute finish at “ + df.format(new Date()));</p>
<p>        }</p>
<p>    }</p>
<p>在Android 4.1.1的设备上运行上述程序，日志如图11-3所示，很显然，我们的目的达到了，成功地让AsyncTask在4.1.1的手机上并行起来了。</p>
<p>图11-3　AsyncTask的executeOnExecutor方法的作用</p>
<h3 id="11-2-3-HandlerThread"><a href="#11-2-3-HandlerThread" class="headerlink" title="11.2.3　HandlerThread"></a>11.2.3　HandlerThread</h3><p>HandlerThread继承了Thread，它是一种可以使用Handler的Thread，它的实现也很简单，就是在run方法中通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环，这样在实际的使用中就允许在HandlerThread中创建Handler了。HandlerThread的run方法如下所示。</p>
<p>public void run() {</p>
<p>        mTid &#x3D; Process.myTid();</p>
<p>        Looper.prepare();</p>
<p>        synchronized (this) {</p>
<p>                mLooper &#x3D; Looper.myLooper();</p>
<p>                notifyAll();</p>
<p>        }</p>
<p>        Process.setThreadPriority(mPriority);</p>
<p>        onLooperPrepared();</p>
<p>        Looper.loop();</p>
<p>        mTid &#x3D; -1;</p>
<p>    }</p>
<p>从HandlerThread的实现来看，它和普通的Thread有显著的不同之处。普通Thread主要用于在run方法中执行一个耗时任务，而HandlerThread在内部创建了消息队列，外界需要通过Handler的消息方式来通知HandlerThread执行一个具体的任务。HandlerThread是一个很有用的类，它在Android中的一个具体的使用场景是IntentService，IntentService将在11.2.4节中进行介绍。由于HandlerThread的run方法是一个无限循环，因此当明确不需要再使用HandlerThread时，可以通过它的quit或者quitSa</p>
<p>fely方法来终止线程的执行，这是一个良好的编程习惯。</p>
<h3 id="11-2-4-IntentService"><a href="#11-2-4-IntentService" class="headerlink" title="11.2.4　IntentService"></a>11.2.4　IntentService</h3><p>IntentService是一种特殊的Service，它继承了Service并且它是一个抽象类，因此必须创建它的子类才能使用IntentService。IntentService可用于执行后台耗时的任务，当任务执行后它会自动停止，同时由于IntentService是服务的原因，这导致它的优先级比单纯的线程要高很多，所以IntentService比较适合执行一些高优先级的后台任务，因为它优先级高不容易被系统杀死。在实现上，IntentService封装了HandlerThread和Handler，这一点可以从它的onCreate方法中看出来，如下所示。</p>
<p>public void onCreate() {</p>
<p>        &#x2F;&#x2F; TODO: It would be nice to have an option to hold a partial wakelock</p>
<p>        &#x2F;&#x2F; during processing,and to have a static startService(Context,Intent)</p>
<p>        &#x2F;&#x2F; method that would launch the service &amp; hand off a wakelock.</p>
<p>        super.onCreate();</p>
<p>        HandlerThread thread &#x3D; new HandlerThread(“IntentService[“ + mName + “]”);</p>
<p>        thread.start();</p>
<p>        mServiceLooper &#x3D; thread.getLooper();</p>
<p>        mServiceHandler &#x3D; new ServiceHandler(mServiceLooper);</p>
<p>    }</p>
<p>当IntentService被第一次启动时，它的onCreate方法会被调用，onCreate方法会创建一个HandlerThread，然后使用它的Looper来构造一个Handler对象mServiceHandler，这样通过mServiceHandler发送的消息最终都会在HandlerThread中执行，从这个角度来看，IntentService也可以用于执行后台任务。每次启动IntentService，它的onStartCommand方法就会调用一次，IntentService在onStartCommand中处理每个后台任务的Intent。下面看一下onStartCommand方法是如何处理外界的Intent的，onStartCommand调用了onStart，onStart方法的实现如下所示。</p>
<p>public void onStart(Intent intent,int startId) {</p>
<p>        Message msg &#x3D; mServiceHandler.obtainMessage();</p>
<p>        msg.arg1 &#x3D; startId;</p>
<p>        msg.obj &#x3D; intent;</p>
<p>        mServiceHandler.sendMessage(msg);</p>
<p>    }</p>
<p>可以看出，IntentService仅仅是通过mServiceHandler发送了一个消息，这个消息会在HandlerThread中被处理。mServiceHandler收到消息后，会将Intent对象传递给onHandleIntent方法去处理。注意这个Intent对象的内容和外界的startService(intent)中的intent的内容是完全一致的，通过这个Intent对象即可解析出外界启动IntentService时所传递的参数，通过这些参数就可以区分具体的后台任务，这样在onHandleIntent方法中就可以对不同的后</p>
<p>台任务做处理了。当onHandleIntent方法执行结束后，IntentService会通过stopSelf(int startId)方法来尝试停止服务。这里之所以采用stopSelf(int startId)而不是stopSelf()来停止服务，那是因为stopSelf()会立刻停止服务，而这个时候可能还有其他消息未处理，stopSelf(int startId)则会等待所有的消息都处理完毕后才终止服务。一般来说，stopSelf(int startId)在尝试停止服务之前会判断最近启动服务的次数是否和startId相等，如果相等就立刻停止服务，不相等则不停止服务，这个策略可以从AMS的stopServiceToken方法的实现中找到依据，读者感兴趣的话可以自行查看源码实现。ServiceHandler的实现如下所示。</p>
<p>private final class ServiceHandler extends Handler {</p>
<p>        public ServiceHandler(Looper looper) {</p>
<p>                super(looper);</p>
<p>        }</p>
<p>        @Override</p>
<p>        public void handleMessage(Message msg) {</p>
<p>                onHandleIntent((Intent)msg.obj);</p>
<p>                stopSelf(msg.arg1);</p>
<p>        }</p>
<p>    }</p>
<p>IntentService的onHandleIntent方法是一个抽象方法，它需要我们在子类中实现，它的作用是从Intent参数中区分具体的任务并执行这些任务。如果目前只存在一个后台任务，那么onHandleIntent方法执行完这个任务后，stopSelf(int startId)就会直接停止服务；如果</p>
<p>目前存在多个后台任务，那么当onHandleIntent方法执行完最后一个任务时，stopSelf(int startId)才会直接停止服务。另外，由于每执行一个后台任务就必须启动一次IntentService，而IntentService内部则通过消息的方式向HandlerThread请求执行任务，Handler中的Looper是顺序处理消息的，这就意味着IntentService也是顺序执行后台任务的，当有多个后台任务同时存在时，这些后台任务会按照外界发起的顺序排队执行。</p>
<p>下面通过一个示例来进一步说明IntentService的工作方式，首先派生一个IntentService的子类，比如LocalIntentService，它的实现如下所示。</p>
<p>public class LocalIntentService extends IntentService {</p>
<p>         private static final String TAG &#x3D; “LocalIntentService”;</p>
<p>         public LocalIntentService() {</p>
<p>             super(TAG);</p>
<p>         }</p>
<p>         @Override</p>
<p>         protected void onHandleIntent(Intent intent) {</p>
<p>             String action &#x3D; intent.getStringExtra(“task_action”);</p>
<p>             Log.d(TAG,”receive task :” +  action);</p>
<p>             SystemClock.sleep(3000);</p>
<p>             if (“com.ryg.action.TASK1”.equals(action)) {</p>
<p>                 Log.d(TAG,”handle task: “ + action);</p>
<p>             }</p>
<p>         }</p>
<p>         @Override</p>
<p>  </p>
<p>public void onDestroy() {</p>
<p>             Log.d(TAG,”service destroyed.”);</p>
<p>             super.onDestroy();</p>
<p>         }</p>
<p>    }</p>
<p>这里对LocalIntentService的实现做一下简单的说明。在onHandleIntent方法中会从参数中解析出后台任务的标识，即task_action字段所代表的内容，然后根据不同的任务标识来执行具体的后台任务。这里为了简单起见，直接通过SystemClock.sleep(3000)来休眠3000毫秒从而模拟一种耗时的后台任务，另外为了验证IntentService的停止时机，这里在onDestroy()中打印了一句日志。LocalIntentService实现完成了以后，就可以在外界请求执行后台任务了，在下面的代码中先后发起了3个后台任务的请求：</p>
<p>Intent service &#x3D; new Intent(this,LocalIntentService.class);</p>
<p>    service.putExtra(“task_action”,”com.ryg.action.TASK1”);</p>
<p>    startService(service);</p>
<p>    service.putExtra(“task_action”,”com.ryg.action.TASK2”);</p>
<p>    startService(service);</p>
<p>    service.putExtra(“task_action”,”com.ryg.action.TASK3”);</p>
<p>    startService(service);</p>
<p>运行程序，观察日志，如下所示。</p>
<p>05-17 17:08:23.186 E&#x2F;dalvikvm(25793): threadid&#x3D;11: calling run(),name&#x3D;IntentService[LocalIntentService]</p>
<p>    05-17 17:08:23.1</p>
<p>96 D&#x2F;LocalIntentService(25793): receive task :com.ryg.action.TASK1</p>
<p>    05-17 17:08:26.199 D&#x2F;LocalIntentService(25793): handle task: com.ryg.action.TASK1</p>
<p>    05-17 17:08:26.199 D&#x2F;LocalIntentService(25793): receive task :com.ryg.action.TASK2</p>
<p>    05-17 17:08:29.192 D&#x2F;LocalIntentService(25793): receive task :com.ryg.action.TASK3</p>
<p>    05-17 17:08:32.205 D&#x2F;LocalIntentService(25793): service destroyed.</p>
<p>         05-17 17:08:32.205 E&#x2F;dalvikvm(25793): threadid&#x3D;11: exiting,name&#x3D;IntentService[LocalIntentService]</p>
<p>从上面的日志可以看出，三个后台任务是排队执行的，它们的执行顺序就是它们发起请求对的顺序，即TASK1、TASK2、TASK3。另外一点就是当TASK3执行完毕后，LocalIntentService才真正地停止，从日志中可以看出LocalIntentService执行了onDestroy()，这也意味着服务正在停止。</p>
<h2 id="11-3-Android中的线程池"><a href="#11-3-Android中的线程池" class="headerlink" title="11.3　Android中的线程池"></a>11.3　Android中的线程池</h2><p>提到线程池就必须先说一下线程池的好处，相信读者都有所体会，线程池的优点可以概括为以下三点：</p>
<p>（1）重用线程池中的线程，避免因为线程的创建和销毁所带来的性能开销。</p>
<p>（2）能有效控制线程池的最大并发数，避</p>
<p>免大量的线程之间因互相抢占系统资源而导致的阻塞现象。</p>
<p>（3）能够对线程进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。</p>
<p>Android中的线程池的概念来源于Java中的Executor，Executor是一个接口，真正的线程池的实现为ThreadPoolExecutor。ThreadPoolExecutor提供了一系列参数来配置线程池，通过不同的参数可以创建不同的线程池，从线程池的功能特性上来说，Android的线程池主要分为4类，这4类线程池可以通过Executors所提供的工厂方法来得到，具体会在11.3.2节中进行详细介绍。由于Android中的线程池都是直接或者间接通过配置ThreadPoolExecutor来实现的，因此在介绍它们之前需要先介绍ThreadPoolExecutor。</p>
<h3 id="11-3-1-ThreadPoolExecutor"><a href="#11-3-1-ThreadPoolExecutor" class="headerlink" title="11.3.1　ThreadPoolExecutor"></a>11.3.1　ThreadPoolExecutor</h3><p>ThreadPoolExecutor是线程池的真正实现，它的构造方法提供了一系列参数来配置线程池，下面介绍ThreadPoolExecutor的构造方法中各个参数的含义，这些参数将会直接影响到线程池的功能特性，下面是ThreadPoolExecutor的一个比较常用的构造方法。</p>
<p>public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,</p>
<p>                                                  long keepAliveTime,</p>
<p>                                                  TimeUnit unit,</p>
<p>                                                  BlockingQueue<Runnable> workQueue,</p>
<p>                                                  ThreadFactory threadFactory)</p>
<p>corePoolSize</p>
<p>线程池的核心线程数，默认情况下，核心线程会在线程池中一直存活，即使它们处于闲置状态。如果将ThreadPoolExecutor的allowCoreThreadTimeOut属性设置为true，那么闲置的核心线程在等待新任务到来时会有超时策略，这个时间间隔由keepAliveTime所指定，当等待时间超过keepAliveTime所指定的时长后，核心线程就会被终止。</p>
<p>maximumPoolSize</p>
<p>线程池所能容纳的最大线程数，当活动线程数达到这个数值后，后续的新任务将会被阻塞。</p>
<p>keepAliveTime</p>
<p>非核心线程闲置时的超时时长，超过这个时长，非核心线程就会被回收。当ThreadPool-Executor的allowCoreThreadTimeOut属性设置为true时，keepAliveTime同样会作用于核心线程。</p>
<p>unit</p>
<p>用于指定keepAliveTime参数的时间单位，这是一个枚举，常用的有TimeUnit. MILLIS</p>
<p>ECONDS（毫秒）、TimeUnit.SECONDS（秒）以及TimeUnit.MINUTES（分钟）等。</p>
<p>workQueue</p>
<p>线程池中的任务队列，通过线程池的execute方法提交的Runnable对象会存储在这个参数中。</p>
<p>threadFactory</p>
<p>线程工厂，为线程池提供创建新线程的功能。ThreadFactory是一个接口，它只有一个方法：Thread newThread(Runnable r)。</p>
<p>除了上面的这些主要参数外，ThreadPoolExecutor还有一个不常用的参数Rejected-ExecutionHandler handler。当线程池无法执行新任务时，这可能是由于任务队列已满或者是无法成功执行任务，这个时候ThreadPoolExecutor会调用handler的rejectedExecution方法来通知调用者，默认情况下rejectedExecution方法会直接抛出一个RejectedExecution-Exception。ThreadPoolExecutor为RejectedExecutionHandler提供了几个可选值：CallerRunsPolicy、AbortPolicy、DiscardPolicy和DiscardOldestPolicy，其中AbortPolicy是默认值，它会直接抛出RejectedExecutionException，由于handler这个参数不常用，这里就不再具体介绍了。</p>
<p>ThreadPoolExecutor执行任务时大致遵循如下规则：</p>
<p>（1）如果线程池中的线程数量未达到核心线程的数量，那么会直接启动一个核心线程来执行任务。</p>
<p>（2）如果线程池中的线程数量已经达到或者超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行。</p>
<p>（3）如果在步骤2中无法将任务插入到任务队列中，这往往是由于任务队列已满，这个时候如果线程数量未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务。</p>
<p>（4）如果步骤3中线程数量已经达到线程池规定的最大值，那么就拒绝执行此任务，ThreadPoolExecutor会调用RejectedExecutionHandler的rejectedExecution方法来通知调 用者。</p>
<p>ThreadPoolExecutor的参数配置在AsyncTask中有明显的体现，下面是AsyncTask中的线程池的配置情况：</p>
<p>private static final int CPU_COUNT &#x3D; Runtime.getRuntime().availableProcessors();</p>
<p>    private static final int CORE_POOL_SIZE &#x3D; CPU_COUNT + 1;</p>
<p>    private static final int MAXIMUM_POOL_SIZE &#x3D; CPU_COUNT * 2 + 1;</p>
<p>    private static final int KEEP_ALIVE &#x3D; 1;</p>
<p>    private static final ThreadFacto</p>
<p>ry sThreadFactory &#x3D; new ThreadFactory() {</p>
<p>        private final AtomicInteger mCount &#x3D; new AtomicInteger(1);</p>
<p>        public Thread newThread(Runnable r) {</p>
<p>                return new Thread(r,”AsyncTask #” + mCount.getAndIncrement());</p>
<p>        }</p>
<p>    };</p>
<p>    private static final BlockingQueue<Runnable> sPoolWorkQueue &#x3D;</p>
<p>                new LinkedBlockingQueue<Runnable>(128);</p>
<p>     &#x2F;**</p>
<p>      * An {@link Executor} that can be used to execute tasks in parallel.</p>
<p>      *&#x2F;</p>
<p>    public static final Executor THREAD_POOL_EXECUTOR</p>
<p>                &#x3D; new ThreadPoolExecutor(CORE_POOL_SIZE,MAXIMUM_POOL_SIZE,KEEP_                      ALIVE,  TimeUnit.SECONDS,sPoolWorkQueue,sThreadFactory);</p>
<p>从上面的代码可以知道，AsyncTask对THREAD_POOL_EXECUTOR这个线程池进行了配置，配置后的线程池规格如下：</p>
<p>核心线程数等于CPU核心数+1；</p>
<p>线程池的最大线程数为CPU核心数的2倍+1；</p>
<p>核心线程无超时机制，非核心线程在闲置时的超时时间为1秒；</p>
<p>任务队列的容量为128。</p>
<h3 id="11-3-2-线程池的分类"><a href="#11-3-2-线程池的分类" class="headerlink" title="11.3.2　线程池的分类"></a>11.3.2　线程池的分类</h3><p>在11.3.1节中对ThreadPoolExecutor的配置细节进行了详细的介绍，本节将接着介绍Android中最常见的四类具有不同功能特性的线程池，它们都直接或间接地通过配置ThreadPoolExecutor来实现自己的功能特性，这四类线程池分别是FixedThreadPool、CachedThreadPool、ScheduledThreadPool以及SingleThreadExecutor。</p>
<ol>
<li>FixedThreadPool</li>
</ol>
<p>通过Executors的newFixedThreadPool方法来创建。它是一种线程数量固定的线程池，当线程处于空闲状态时，它们并不会被回收，除非线程池被关闭了。当所有的线程都处于活动状态时，新任务都会处于等待状态，直到有线程空闲出来。由于FixedThreadPool只有核心线程并且这些核心线程不会被回收，这意味着它能够更加快速地响应外界的请求。newFixedThreadPool方法的实现如下，可以发现FixedThreadPool中只有核心线程并且这些核心线程没有超时机制，另外任务队列也是没有大小限制的。</p>
<p>public static ExecutorService newFixedThreadPool(int nThreads) {</p>
<p>        return new ThreadPoolExecutor(nThreads,nThreads,</p>
<p>                         0L,TimeUnit.MILLISECONDS,</p>
<p>                                                                  new LinkedBlockingQueue<Runnable>());</p>
<p>    }</p>
<ol start="2">
<li>CachedThreadPool</li>
</ol>
<p>通过Executors的newCachedThreadPool方法来创建。它是一种线程数量不定的线程池，它只有非核心线程，并且其最大线程数为Integer.MAX_VALUE。由于Integer.MAX_VALUE是一个很大的数，实际上就相当于最大线程数可以任意大。当线程池中的线程都处于活动状态时，线程池会创建新的线程来处理新任务，否则就会利用空闲的线程来处理新任务。线程池中的空闲线程都有超时机制，这个超时时长为60秒，超过60秒闲置线程就会被回收。和FixedThreadPool不同的是，CachedThreadPool的任务队列其实相当于一个空集合，这将导致任何任务都会立即被执行，因为在这种场景下SynchronousQueue是无法插入任务的。SynchronousQueue是一个非常特殊的队列，在很多情况下可以把它简单理解为一个无法存储元素的队列，由于它在实际中较少使用，这里就不深入探讨它了。从CachedThreadPool的特性来看，这类线程池比较适合执行大量的耗时较少的任务。当整个线程池都处于闲置状态时，线程池中的线程都会超时而被停止，这个时候CachedThreadPool之中实际上是没有任何线程的，它几乎是不占用任何系统资源的。newCachedThreadPool方法的实现如下所示。</p>
<p>public static ExecutorService newCachedThreadPool() {</p>
<p>        return new ThreadPoolExecutor(0,Integer.MAX_VALUE,</p>
<p>       </p>
<p> 60L,TimeUnit.SECONDS,</p>
<p>                                     new SynchronousQueue<Runnable>());</p>
<p>    }</p>
<ol start="3">
<li>ScheduledThreadPool</li>
</ol>
<p>通过Executors的newScheduledThreadPool方法来创建。它的核心线程数量是固定的，而非核心线程数是没有限制的，并且当非核心线程闲置时会被立即回收。ScheduledThreadPool这类线程池主要用于执行定时任务和具有固定周期的重复任务，newScheduledThreadPool方法的实现如下所示。</p>
<p>public static ScheduledExecutorService newScheduledThreadPool(int</p>
<p>    corePoolSize) {</p>
<p>        return new ScheduledThreadPoolExecutor(corePoolSize);</p>
<p>    }</p>
<p>    public ScheduledThreadPoolExecutor(int corePoolSize) {</p>
<p>        super(corePoolSize,Integer.MAX_VALUE,0,NANOSECONDS,</p>
<p>                  new DelayedWorkQueue());</p>
<p>    }</p>
<ol start="4">
<li>SingleThreadExecutor</li>
</ol>
<p>通过Executors的newSingleThreadExecutor方法来创建。这类线程池内部只有一个核心线程，它确保所有的任务都在同一个线程中按顺序执行。SingleThreadExecutor的意义在于统一所有的外界任务到一个线程中，这使得在这些任务之间不需要处理线程同步的问题。ne</p>
<p>wSingleThreadExecutor方法的实现如下所示。</p>
<p>public static ExecutorService newSingleThreadExecutor() {</p>
<p>        return new FinalizableDelegatedExecutorService</p>
<p>                (new ThreadPoolExecutor(1,1,</p>
<p>                                       0L,TimeUnit.MILLISECONDS,</p>
<p>                                       new LinkedBlockingQueue<Runnable>()));</p>
<p>    }</p>
<p>上面对Android中常见的4种线程池进行了详细的介绍，除了上面系统提供的4类线程池以外，也可以根据实际需要灵活地配置线程池。下面的代码演示了系统预置的4种线程池的典型使用方法。</p>
<p>Runnable command &#x3D; new Runnable() {</p>
<p>        @Override</p>
<p>        public void run() {</p>
<p>                SystemClock.sleep(2000);</p>
<p>        }</p>
<p>    };</p>
<p>    ExecutorService fixedThreadPool &#x3D; Executors.newFixedThreadPool(4);</p>
<p>    fixedThreadPool.execute(command);</p>
<p>    ExecutorService cachedThreadPool &#x3D; Executors.newCachedThreadPool();</p>
<p>    cachedThreadPool.execute(command);</p>
<p>    ScheduledExecutorService scheduledThreadPool &#x3D; Executors.newScheduled-ThreadPool(4);</p>
<p>    &#x2F;&#x2F; 2000ms后执行command</p>
<p>    scheduledThreadPool.schedule(command,2000,TimeUnit.MILLISECONDS);</p>
<p>&#x2F;&#x2F; 延迟10ms后，每隔1000ms执行一次command</p>
<p>    scheduledThreadPool.scheduleAtFixedRate(command,10,1000,TimeUnit. MILLISECONDS);</p>
<p>    ExecutorService singleThreadExecutor &#x3D; Executors.newSingleThread-Executor();</p>
<p>    singleThreadExecutor.execute(command);</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/android/">android</a></div><div class="post_share"><div class="social-share" data-image="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2Fd5f80e1a-f4c1-4f5c-aad2-fe213ae89f64%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&amp;refer=http%3A%2F%2Fsafe-img.xhscdn.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1710160772&amp;t=4038984b7822fc46c9a8d50e0c5106b4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/01/10/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC10%E7%AB%A0%20Android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/" title="第十章　Android的消息机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第十章　Android的消息机制</div></div></a></div><div class="next-post pull-right"><a href="/2021/01/12/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC12%E7%AB%A0%20Bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8CCache/" title="第十二章　Bitmap的加载和Cache"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第十二章　Bitmap的加载和Cache</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/01/10/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC10%E7%AB%A0%20Android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/" title="第十章　Android的消息机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-10</div><div class="title">第十章　Android的消息机制</div></div></a></div><div><a href="/2021/01/13/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC13%E7%AB%A0%20%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/" title="第十三章 综合技术"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-13</div><div class="title">第十三章 综合技术</div></div></a></div><div><a href="/2021/01/14/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC14%E7%AB%A0%20JNI%E5%92%8CNDK%E7%BC%96%E7%A8%8B/" title="第十四章 JNI和NDK编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-14</div><div class="title">第十四章 JNI和NDK编程</div></div></a></div><div><a href="/2021/01/12/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC12%E7%AB%A0%20Bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8CCache/" title="第十二章　Bitmap的加载和Cache"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-12</div><div class="title">第十二章　Bitmap的加载和Cache</div></div></a></div><div><a href="/2021/01/15/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC15%E7%AB%A0%20Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="第十五章 Android性能优化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-15</div><div class="title">第十五章 Android性能优化</div></div></a></div><div><a href="/2021/01/04/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC4%E7%AB%A0%20View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" title="第四章　View的工作原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-04</div><div class="title">第四章　View的工作原理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2Fd5f80e1a-f4c1-4f5c-aad2-fe213ae89f64%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&amp;refer=http%3A%2F%2Fsafe-img.xhscdn.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1710160772&amp;t=4038984b7822fc46c9a8d50e0c5106b4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Junyong Tu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" href="https://github.com/juncaixingchi1993"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%AD%90%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">11.1　主线程和子线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-Android%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%BD%A2%E6%80%81"><span class="toc-number">2.</span> <span class="toc-text">11.2　Android中的线程形态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-1-AsyncTask"><span class="toc-number">2.1.</span> <span class="toc-text">11.2.1　AsyncTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-2-AsyncTask%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">11.2.2　AsyncTask的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-3-HandlerThread"><span class="toc-number">2.3.</span> <span class="toc-text">11.2.3　HandlerThread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-4-IntentService"><span class="toc-number">2.4.</span> <span class="toc-text">11.2.4　IntentService</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-Android%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">3.</span> <span class="toc-text">11.3　Android中的线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-1-ThreadPoolExecutor"><span class="toc-number">3.1.</span> <span class="toc-text">11.3.1　ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.2.</span> <span class="toc-text">11.3.2　线程池的分类</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/01/15/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC15%E7%AB%A0%20Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="第十五章 Android性能优化">第十五章 Android性能优化</a><time datetime="2021-01-15T14:07:08.000Z" title="发表于 2021-01-15 22:07:08">2021-01-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/01/14/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC14%E7%AB%A0%20JNI%E5%92%8CNDK%E7%BC%96%E7%A8%8B/" title="第十四章 JNI和NDK编程">第十四章 JNI和NDK编程</a><time datetime="2021-01-14T14:07:08.000Z" title="发表于 2021-01-14 22:07:08">2021-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/01/13/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC13%E7%AB%A0%20%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/" title="第十三章 综合技术">第十三章 综合技术</a><time datetime="2021-01-13T14:07:08.000Z" title="发表于 2021-01-13 22:07:08">2021-01-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/01/12/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC12%E7%AB%A0%20Bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8CCache/" title="第十二章　Bitmap的加载和Cache">第十二章　Bitmap的加载和Cache</a><time datetime="2021-01-12T14:07:08.000Z" title="发表于 2021-01-12 22:07:08">2021-01-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/01/11/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC11%E7%AB%A0%20Android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="第十一章　Android的线程和线程池">第十一章　Android的线程和线程池</a><time datetime="2021-01-11T14:07:08.000Z" title="发表于 2021-01-11 22:07:08">2021-01-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Junyong Tu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>