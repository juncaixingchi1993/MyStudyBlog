<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>第七章　Android动画深入分析 | Junyong Tu の 杂记</title><meta name="author" content="Junyong Tu"><meta name="copyright" content="Junyong Tu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Android的动画可以分为三种：View动画、帧动画和属性动画，其实帧动画也属于View动画的一种，只不过它和平移、旋转等常见的View动画在表现形式上略有不同而已。View动画通过对场景里的对象不断做图像变换（平移、缩放、旋转、透明度）从而产生动画效果，它是一种渐近式动画，并且View动画支持自定义。帧动画通过顺序播放一系列图像从而产生动画效果，可以简单理解为图片切换动画，很显然，如果图片过多">
<meta property="og:type" content="article">
<meta property="og:title" content="第七章　Android动画深入分析">
<meta property="og:url" content="https://github.com/juncaixingchi1993/juncaixingchi1993.github.io/2021/01/07/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC7%E7%AB%A0%20Android%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Junyong Tu の 杂记">
<meta property="og:description" content="Android的动画可以分为三种：View动画、帧动画和属性动画，其实帧动画也属于View动画的一种，只不过它和平移、旋转等常见的View动画在表现形式上略有不同而已。View动画通过对场景里的对象不断做图像变换（平移、缩放、旋转、透明度）从而产生动画效果，它是一种渐近式动画，并且View动画支持自定义。帧动画通过顺序播放一系列图像从而产生动画效果，可以简单理解为图片切换动画，很显然，如果图片过多">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2Fd5f80e1a-f4c1-4f5c-aad2-fe213ae89f64%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1710160772&t=4038984b7822fc46c9a8d50e0c5106b4">
<meta property="article:published_time" content="2021-01-07T14:07:08.000Z">
<meta property="article:modified_time" content="2024-02-14T11:19:53.947Z">
<meta property="article:author" content="Junyong Tu">
<meta property="article:tag" content="android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2Fd5f80e1a-f4c1-4f5c-aad2-fe213ae89f64%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&refer=http%3A%2F%2Fsafe-img.xhscdn.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1710160772&t=4038984b7822fc46c9a8d50e0c5106b4"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://github.com/juncaixingchi1993/juncaixingchi1993.github.io/2021/01/07/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC7%E7%AB%A0%20Android%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '第七章　Android动画深入分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-14 19:19:53'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2Fd5f80e1a-f4c1-4f5c-aad2-fe213ae89f64%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&amp;refer=http%3A%2F%2Fsafe-img.xhscdn.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1710160772&amp;t=4038984b7822fc46c9a8d50e0c5106b4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img2.baidu.com/it/u=1361506290,4036378790&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500')"><nav id="nav"><span id="blog-info"><a href="/" title="Junyong Tu の 杂记"><span class="site-name">Junyong Tu の 杂记</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第七章　Android动画深入分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-07T14:07:08.000Z" title="发表于 2021-01-07 22:07:08">2021-01-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-14T11:19:53.947Z" title="更新于 2024-02-14 19:19:53">2024-02-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/">艺术探索</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="第七章　Android动画深入分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Android的动画可以分为三种：View动画、帧动画和属性动画，其实帧动画也属于View动画的一种，只不过它和平移、旋转等常见的View动画在表现形式上略有不同而已。View动画通过对场景里的对象不断做图像变换（平移、缩放、旋转、透明度）从而产生动画效果，它是一种渐近式动画，并且View动画支持自定义。帧动画通过顺序播放一系列图像从而产生动画效果，可以简单理解为图片切换动画，很显然，如果图片过多过大就会导致OOM。属性动画通过动态地改变对象的属性从而达到动画效果，属性动画为API 11的新特性，在低版本无法直接使用属性动画，但是我们仍然可以通过兼容库来使用它。在本章中，首先简单介绍View动画以及自定义View动画的方式，接着介绍View动画的一些特殊的使用场景，最后对属性动画做一个全面性的介绍，另外还介绍使用动画的一些注意事项。</p>
<h2 id="7-1-View动画"><a href="#7-1-View动画" class="headerlink" title="7.1　View动画"></a>7.1　View动画</h2><p>View动画的作用对象是View，它支持4种动画效果，分别是平移动画、缩放动画、旋转动画和透明度动画。除了这四种典型的变换效果外，帧动画也属于View动画，但是帧动画的表现形式和上面的四种变换效果不太一样。为了更好地区分这四种变换和帧动画，在本章中如</p>
<p>果没有特殊说明，那么所提到的View动画均指这四种变换，帧动画会单独介绍。本节将介绍View动画的四种效果以及帧动画，同时还会介绍自定义View动画的方法。</p>
<h3 id="7-1-1-View动画的种类"><a href="#7-1-1-View动画的种类" class="headerlink" title="7.1.1　View动画的种类"></a>7.1.1　View动画的种类</h3><p>View动画的四种变换效果对应着Animation的四个子类：TranslateAnimation、ScaleAnimation、RotateAnimation和AlphaAnimation，如表7-1所示。这四种动画既可以通过XML来定义，也可以通过代码来动态创建，对于View动画来说，建议采用XML来定义动画，这是因为XML格式的动画可读性更好。</p>
<p>表7-1　View动画的四种变换</p>
<p>要使用View动画，首先要创建动画的XML文件，这个文件的路径为：res&#x2F;anim&#x2F;filename.xml。View动画的描述文件是有固定的语法的，如下所示。</p>
<?xml version="1.0" encoding="utf-8"?>

<p>    &lt;set xmlns:android&#x3D;”<a target="_blank" rel="noopener" href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>“</p>
<p>         android:interpolator&#x3D;”@[package:]anim&#x2F;interpolator_resource”</p>
<p>         android:shareInterpolator&#x3D;[“true” | “false”] &gt;</p>
<p>         &lt;alpha</p>
<p>             android:fromAlpha&#x3D;”float”</p>
<p> </p>
<p>android:toAlpha&#x3D;”float” &#x2F;&gt;</p>
<p>         &lt;scale</p>
<p>             android:fromXScale&#x3D;”float”</p>
<p>             android:toXScale&#x3D;”float”</p>
<p>             android:fromYScale&#x3D;”float”</p>
<p>             android:toYScale&#x3D;”float”</p>
<p>             android:pivotX&#x3D;”float”</p>
<p>             android:pivotY&#x3D;”float” &#x2F;&gt;</p>
<p>         &lt;translate</p>
<p>             android:fromXDelta&#x3D;”float”</p>
<p>             android:toXDelta&#x3D;”float”</p>
<p>             android:fromYDelta&#x3D;”float”</p>
<p>             android:toYDelta&#x3D;”float” &#x2F;&gt;</p>
<p>         &lt;rotate</p>
<p>             android:fromDegrees&#x3D;”float”</p>
<p>             android:toDegrees&#x3D;”float”</p>
<p>             android:pivotX&#x3D;”float”</p>
<p>             android:pivotY&#x3D;”float” &#x2F;&gt;</p>
<p>         <set></p>
<p>             …</p>
<p>         </set></p>
<p>    </set></p>
<p>从上面的语法可以看出，View动画既可以是单个动画，也可以由一系列动画组成。</p>
<p><set>标签表示动画集合，对应AnimationSet类，它可以包含若干个动画，并且它的内部也是可以嵌套其他动画集合的，它的两个属性的含义如下：</p>
<p>android:interpolator</p>
<p>表示动画集合所采用的插值器，插值器影响动画的速度，比如非匀速动画就需要通过插值器来控制动画的播放过程。这个属性可以不</p>
<p>指定，默认为@android:anim&#x2F;accelerate_decelerate_interpolator，即加速减速插值器，关于插值器的概念会在7.3.2节中进行具体介绍。</p>
<p>android:shareInterpolator</p>
<p>表示集合中的动画是否和集合共享同一个插值器。如果集合不指定插值器，那么子动画就需要单独指定所需的插值器或者使用默认值。</p>
<p><translate>标签标示平移动画，对应TranslateAnimation类，它可以使一个View在水平和竖直方向完成平移的动画效果，它的一系列属性的含义如下：</p>
<p>android:fromXDelta——表示x的起始值，比如0；</p>
<p>android:toXDelta——表示x的结束值，比如100；</p>
<p>android:fromYDelta——表示y的起始值；</p>
<p>android:toYDelta——表示y的结束值。</p>
<p><scale>标签表示缩放动画，对应ScaleAnimation，它可以使View具有放大或者缩小的动画效果，它的一系列属性的含义如下：</p>
<p>android:fromXScale——水平方向缩放的起始值，比如0.5；</p>
<p>android:toXScale——水平方向缩放的结束值，比如1.2；</p>
<p>android:fromYScale——竖直方向缩放的起始值；</p>
<p>android:toYScale——竖直方向缩放的起始值；</p>
<p>android:pivotX——缩放的轴点的x坐标，它会影响缩放的效果；</p>
<p>android:pivotY——缩放的轴点的y坐标，它会影响缩放的效果。</p>
<p>在<scale>标签中提到了轴点的概念，这里举个例子，默认情况下轴点是View的中心点，这个时候在水平方向进行缩放的话会导致View向左右两个方向同时进行缩放，但是如果把轴点设为View的右边界，那么View就只会向左边进行缩放，反之则向右边进行缩放，具体效果读者可以自己测试一下。</p>
<p><rotate>标签表示旋转动画，对于RotateAnimation，它可以使View具有旋转的动画效果，它的属性的含义如下：</p>
<p>android:fromDegrees——旋转开始的角度，比如0；</p>
<p>android:toDegrees——旋转结束的角度，比如180；</p>
<p>android:pivotX——旋转的轴点的x坐标；</p>
<p>android:pivotY——旋转的轴点的y坐标。</p>
<p>在旋转动画中也有轴点的概念，它也会影</p>
<p>响到旋转的具体效果。在旋转动画中，轴点扮演着旋转轴的角色，即View是围绕着轴点进行旋转的，默认情况下轴点为View的中心点。考虑一种情况，View围绕着自己的中心点和围绕着自己的左上角旋转90度显然是不同的旋转轨迹，不同轴点对旋转效果的影响读者可以自己测试一下。</p>
<p><alpha>标签表示透明度动画，对应AlphaAnimation，它可以改变View的透明度，它的属性的含义如下：</p>
<p>android:fromAlpha——表示透明度的起始值，比如0.1；</p>
<p>android:toAlpha——表示透明度的结束值，比如1。</p>
<p>上面简单介绍了View动画的XML格式，具体的使用方法查看相关文档。除了上面介绍的属性以外，View动画还有一些常用的属性，如下所示。</p>
<p>android:duration——动画的持续时间；</p>
<p>android:fillAfter——动画结束以后View是否停留在结束位置，true表示View停留在结束位置，false则不停留。</p>
<p>下面是一个实际的例子：</p>
<p>&#x2F;&#x2F; res&#x2F;anim&#x2F;animation_test.xml</p>
<p>    &lt;?xml v</p>
<p>ersion&#x3D;”1.0” encoding&#x3D;”utf-8”?&gt;</p>
<p>    &lt;set xmlns:android&#x3D;”<a target="_blank" rel="noopener" href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>“</p>
<p>         android:fillAfter&#x3D;”true”</p>
<p>         android:zAdjustment&#x3D;”normal” &gt;</p>
<p>         &lt;translate</p>
<p>             android:duration&#x3D;”100”</p>
<p>             android:fromXDelta&#x3D;”0”</p>
<p>             android:fromYDelta&#x3D;”0”</p>
<p>             android:interpolator&#x3D;”@android:anim&#x2F;linear_interpolator”</p>
<p>             android:toXDelta&#x3D;”100”</p>
<p>             android:toYDelta&#x3D;”100” &#x2F;&gt;</p>
<p>         &lt;rotate</p>
<p>             android:duration&#x3D;”400”</p>
<p>             android:fromDegrees&#x3D;”0”</p>
<p>             android:toDegrees&#x3D;”90” &#x2F;&gt;</p>
<p>    </set></p>
<p>如何应用上面的动画呢？也很简单，如下所示。</p>
<p>Button mButton &#x3D; (Button) findViewById(R.id.button1);</p>
<p>    Animation animation &#x3D; AnimationUtils.loadAnimation(this,R.anim.animation_</p>
<p>    test);</p>
<p>    mButton.startAnimation(animation);</p>
<p>除了在XML中定义动画外，还可以通过代码来应用动画，这里举个例子，如下所示。</p>
<p>AlphaAnimation alphaAnimation &#x3D; new AlphaAnimation(0,1);</p>
<p>    alphaAnimation.setDuration(300);</p>
<p>    mButton.startAnimation(alphaAnimation);</p>
<p>在上面的代码中，创建了一个透明度动画，将一个Button的透明度在300ms内由0变为1，其他类型的View动画也可以通过代码来创建，这里就不做介绍了。另外，通过Animation的setAnimationListener方法可以给View动画添加过程监听，接口如下所示。从接口的定义可以很清楚地看出每个方法的含义。</p>
<p>public static interface AnimationListener {</p>
<p>        void onAnimationStart(Animation animation);</p>
<p>        void onAnimationEnd(Animation animation);</p>
<p>        void onAnimationRepeat(Animation animation);</p>
<p>    }</p>
<h3 id="7-1-2-自定义View动画"><a href="#7-1-2-自定义View动画" class="headerlink" title="7.1.2　自定义View动画"></a>7.1.2　自定义View动画</h3><p>除了系统提供的四种View动画外，我们还可以自定义View动画。自定义动画是一件既简单又复杂的事情，说它简单，是因为派生一种新动画只需要继承Animation这个抽象类，然后重写它的initialize和applyTransformation方法，在initialize方法中做一些初始化工作，在applyTransformation中进行相应的矩阵变换即可，很多时候需要采用Camera来简化矩阵变换的过程。说它复杂，是因为自定义View动画的过程主要是矩阵变换的过程，而矩阵变换是数学上的概念，如果对这方面的知识不熟悉的话，就会觉得这个过程比较复杂了。</p>
<p>本节不打算详细地讲解自定义View动画的细节，因为这都是数学中的矩阵变换的细节，</p>
<p>读者只需要知道自定义View的方法并在需要的时候参考矩阵变换的细节即可写出特定的自定义View动画。一般来说，在实际开发中很少用到自定义View动画。这里提供一个自定义View动画的例子，这个例子来自于Android的ApiDemos中的一个自定义View动画Rotate3dAnimation。Rotate3dAnimation可以围绕y轴旋转并且同时沿着z轴平移从而实现一种类似于3D的效果，它的代码如下：</p>
<p>public class Rotate3dAnimation extends Animation {</p>
<p>         private final float mFromDegrees;</p>
<p>         private final float mToDegrees;</p>
<p>         private final float mCenterX;</p>
<p>         private final float mCenterY;</p>
<p>         private final float mDepthZ;</p>
<p>         private final boolean mReverse;</p>
<p>         private Camera mCamera;</p>
<p>         &#x2F;**</p>
<p>          * Creates a new 3D rotation on the Y axis. The rotation is defined by its</p>
<p>          * start angle and its end angle. Both angles are in degrees. The rotation</p>
<p>          * is performed around a center point on the 2D space,definied by a pair</p>
<p>          * of X and Y coordinates,called centerX and centerY. When the animation</p>
<p>          * starts,a translation on the Z axis (depth) is performed. The length</p>
<p>          * of the translation ca</p>
<p>n be specified,as well as whether the translation</p>
<p>          * should be reversed in time.</p>
<p>          *</p>
<p>          * @param fromDegrees the start angle of the 3D rotation</p>
<p>          * @param toDegrees the end angle of the 3D rotation</p>
<p>          * @param centerX the X center of the 3D rotation</p>
<p>          * @param centerY the Y center of the 3D rotation</p>
<p>          * @param reverse true if the translation should be reversed,false</p>
<p>            otherwise</p>
<p>          *&#x2F;</p>
<p>         public Rotate3dAnimation(float fromDegrees,float toDegrees,</p>
<p>                 float centerX,float centerY,float depthZ,boolean reverse) {</p>
<p>             mFromDegrees &#x3D; fromDegrees;</p>
<p>             mToDegrees &#x3D; toDegrees;</p>
<p>             mCenterX &#x3D; centerX;</p>
<p>             mCenterY &#x3D; centerY;</p>
<p>             mDepthZ &#x3D; depthZ;</p>
<p>             mReverse &#x3D; reverse;</p>
<p>         }</p>
<p>         @Override</p>
<p>         public void initialize(int width,int height,int parentWidth,int</p>
<p>         parentHeight) {</p>
<p>             super.initialize(width,height,parentWidth,parentHeight);</p>
<p>             mCamera &#x3D; new Camera();</p>
<p>         }</p>
<p>         @Override</p>
<p>         protected void applyTransformation(float interpolatedTime,Transfor-</p>
<p>         mation t) {</p>
<p>  final float fromDegrees &#x3D; mFromDegrees;</p>
<p>             float degrees &#x3D; fromDegrees + ((mToDegrees -fromDegrees) * interpo-</p>
<p>             latedTime);</p>
<p>             final float centerX &#x3D; mCenterX;</p>
<p>             final float centerY &#x3D; mCenterY;</p>
<p>             final Camera camera &#x3D; mCamera;</p>
<p>             final Matrix matrix &#x3D; t.getMatrix();</p>
<p>             camera.save();</p>
<p>             if (mReverse) {</p>
<p>                 camera.translate(0.0f,0.0f,mDepthZ * interpolatedTime);</p>
<p>             } else {</p>
<p>                 camera.translate(0.0f,0.0f,mDepthZ * (1.0f -interpolated-</p>
<p>                 Time));</p>
<p>             }</p>
<p>             camera.rotateY(degrees);</p>
<p>             camera.getMatrix(matrix);</p>
<p>             camera.restore();</p>
<p>             matrix.preTranslate(-centerX,-centerY);</p>
<p>             matrix.postTranslate(centerX,centerY);</p>
<p>         }</p>
<p>    }</p>
<h3 id="7-1-3-帧动画"><a href="#7-1-3-帧动画" class="headerlink" title="7.1.3　帧动画"></a>7.1.3　帧动画</h3><p>帧动画是顺序播放一组预先定义好的图片，类似于电影播放。不同于View动画，系统提供了另外一个类AnimationDrawable来使用帧动画。帧动画的使用比较简单，首先需要通过XML来定义一个AnimationDrawable，如下所示。</p>
<p>&#x2F;&#x2F; res&#x2F;drawable&#x2F;frame_animation.xml</p>
<p>    &lt;?</p>
<p>xml version&#x3D;”1.0” encoding&#x3D;”utf-8”?&gt;</p>
<p>    &lt;animation-list xmlns:android&#x3D;”<a target="_blank" rel="noopener" href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>“</p>
<p>         android:oneshot&#x3D;”false”&gt;</p>
<p>         <item android:drawable="@drawable/image1" android:duration="500" /></p>
<p>         <item android:drawable="@drawable/image2" android:duration="500" /></p>
<p>         <item android:drawable="@drawable/image3" android:duration="500" /></p>
<p>    </animation-list></p>
<p>然后将上述的Drawable作为View的背景并通过Drawable来播放动画即可：</p>
<p>Button mButton &#x3D; (Button)findViewById(R.id.button1);</p>
<p>    mButton.setBackgroundResource(R.drawable.frame_animation);</p>
<p>    AnimationDrawable drawable &#x3D; (AnimationDrawable) mButton.getBackground();</p>
<p>    drawable.start();</p>
<p>帧动画的使用比较简单，但是比较容易引起OOM，所以在使用帧动画时应尽量避免使用过多尺寸较大的图片。</p>
<h2 id="7-2-View动画的特殊使用场景"><a href="#7-2-View动画的特殊使用场景" class="headerlink" title="7.2　View动画的特殊使用场景"></a>7.2　View动画的特殊使用场景</h2><p>在7.1节中我们介绍了View动画的四种形式，除了这四种形式外，View动画还可以在一些特殊的场景下使用，比如在ViewGroup中可以控制子元素的出场效果，在Activity中可以实现</p>
<p>不同Activity之间的切换效果。</p>
<h3 id="7-2-1-LayoutAnimation"><a href="#7-2-1-LayoutAnimation" class="headerlink" title="7.2.1　LayoutAnimation"></a>7.2.1　LayoutAnimation</h3><p>LayoutAnimation作用于ViewGroup，为ViewGroup指定一个动画，这样当它的子元素出场时都会具有这种动画效果。这种效果常常被用在ListView上，我们时常会看到一种特殊的ListView，它的每个item都以一定的动画的形式出现，其实这并非什么高深的技术，它使用的就是LayoutAnimation。LayoutAnimation也是一个View动画，为了给ViewGroup的子元素加上出场效果，遵循如下几个步骤。</p>
<p>（1）定义LayoutAnimation，如下所示。</p>
<p>&#x2F;&#x2F; res&#x2F;anim&#x2F;anim_layout.xml</p>
<p>    &lt;layoutAnimation</p>
<p>         xmlns:android&#x3D;”<a target="_blank" rel="noopener" href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>“</p>
<p>         android:delay&#x3D;”0.5”</p>
<p>         android:animationOrder&#x3D;”normal”</p>
<p>    android:animation&#x3D;”@anim&#x2F;anim_item”&#x2F;&gt;</p>
<p>它的属性的含义如下所示。</p>
<p>android:delay</p>
<p>表示子元素开始动画的时间延迟，比如子元素入场动画的时间周期为300ms，那么0.5表示每个子元素都需要延迟150ms才能播放入场动画。总体来说，第一个子元素延迟150ms开始播放入场动画，第2个子元素延迟300ms开始播放入场动画，依次类推。</p>
<p>android:animationOrder</p>
<p>表示子元素动画的顺序，有三种选项：normal、reverse和random，其中normal表示顺序显示，即排在前面的子元素先开始播放入场动画；reverse表示逆向显示，即排在后面的子元素先开始播放入场动画；random则是随机播放入场动画。</p>
<p>android:animation</p>
<p>为子元素指定具体的入场动画。</p>
<p>（2）为子元素指定具体的入场动画，如下所示。</p>
<p>&#x2F;&#x2F; res&#x2F;anim&#x2F;anim_item.xml</p>
<p>    <?xml version="1.0" encoding="utf-8"?></p>
<p>    &lt;set xmlns:android&#x3D;”<a target="_blank" rel="noopener" href="http://schemas.android.com/apk/res/android">http://schemas.android.com/apk/res/android</a>“</p>
<p>         android:duration&#x3D;”300”</p>
<p>         android:interpolator&#x3D;”@android:anim&#x2F;accelerate_interpolator”</p>
<p>         android:shareInterpolator&#x3D;”true” &gt;</p>
<p>         &lt;alpha</p>
<p>             android:fromAlpha&#x3D;”0.0”</p>
<p>             android:toAlpha&#x3D;”1.0” &#x2F;&gt;</p>
<p>         &lt;translate</p>
<p>             android:fromXDelta&#x3D;”500”</p>
<p>             android:toXDelta&#x3D;”0” &#x2F;&gt;</p>
<p>    </set></p>
<p>（3）为ViewGroup指定android:layoutAnimation属性：android:layoutAnimation&#x3D; “@anim&#x2F; anim_layout”。对于ListView来说，这样ListView的item就具有出场动画了，这种方式适</p>
<p>用于所有的ViewGroup，如下所示。</p>
<p>&lt;ListView</p>
<p>        android:id&#x3D;”@+id&#x2F;list”</p>
<p>        android:layout_width&#x3D;”match_parent”</p>
<p>        android:layout_height&#x3D;”match_parent”</p>
<p>        android:layoutAnimation&#x3D;”@anim&#x2F;anim_layout”</p>
<p>        android:background&#x3D;”#fff4f7f9”</p>
<p>        android:cacheColorHint&#x3D;”#00000000”</p>
<p>        android:divider&#x3D;”#dddbdb”</p>
<p>        android:dividerHeight&#x3D;”1.0px”</p>
<p>        android:listSelector&#x3D;”@android:color&#x2F;transparent” &#x2F;&gt;</p>
<p>除了在XML中指定LayoutAnimation外，还可以通过LayoutAnimationController来实现，具体代码如下所示。</p>
<p>ListView listView &#x3D; (ListView) layout.findViewById(R.id.list);</p>
<p>    Animation animation &#x3D; AnimationUtils.loadAnimation(this,R.anim.anim_</p>
<p>    item);</p>
<p>    LayoutAnimationController controller &#x3D; new LayoutAnimationController</p>
<p>     (animation);</p>
<p>    controller.setDelay(0.5f);</p>
<p>    controller.setOrder(LayoutAnimationController.ORDER_NORMAL);</p>
<p>    listView.setLayoutAnimation(controller);</p>
<h3 id="7-2-2-Activity的切换效果"><a href="#7-2-2-Activity的切换效果" class="headerlink" title="7.2.2　Activity的切换效果"></a>7.2.2　Activity的切换效果</h3><p>Activity有默认的切换效果，但是这个效</p>
<p>果我们是可以自定义的，主要用到overridePendingTransition(int enterAnim,int exitAnim)这个方法，这个方法必须在startActivity(Intent)或者finish()之后被调用才能生效，它的参数含义如下：</p>
<p>enterAnim——Activity被打开时，所需的动画资源id；</p>
<p>exitAnim——Activity被暂停时，所需的动画资源id。</p>
<p>当启动一个Activity时，可以按照如下方式为其添加自定义的切换效果：</p>
<p>Intent intent &#x3D; new Intent(this,TestActivity.class);</p>
<p>    startActivity(intent);</p>
<p>    overridePendingTransition(R.anim.enter_anim,R.anim.exit_anim);</p>
<p>当Activity退出时，也可以为其指定自己的切换效果，如下所示。</p>
<p>@Override</p>
<p>    public void finish() {</p>
<p>        super.finish();</p>
<p>        overridePendingTransition(R.anim.enter_anim,R.anim.exit_anim);</p>
<p>    }</p>
<p>需要注意的是，overridePendingTransition这个方法必须位于startActivity或者finish的后面，否则动画效果将不起作用。</p>
<p>Fragment也可以添加切换动画，由于Fragm</p>
<p>ent是在API 11中新引入的类，因此为了兼容性我们需要使用support-v4这个兼容包，在这种情况下我们可以通过FragmentTransaction中的setCustomAnimations()方法来添加切换动画。这个切换动画需要是View动画，之所以不能采用属性动画是因为属性动画也是API 11新引入的。还有其他方式可以给Activity和Fragment添加切换动画，但是它们大多都有兼容性问题，在低版本上无法使用，因此不具有很高的使用价值，这里就不再一一介绍了。</p>
<h2 id="7-3-属性动画"><a href="#7-3-属性动画" class="headerlink" title="7.3　属性动画"></a>7.3　属性动画</h2><p>属性动画是API 11新加入的特性，和View动画不同，它对作用对象进行了扩展，属性动画可以对任何对象做动画，甚至还可以没有对象。除了作用对象进行了扩展以外，属性动画的效果也得到了加强，不再像View动画那样只能支持四种简单的变换。属性动画中有ValueAnimator、ObjectAnimator和AnimatorSet等概念，通过它们可以实现绚丽的动画。</p>
<h3 id="7-3-1-使用属性动画"><a href="#7-3-1-使用属性动画" class="headerlink" title="7.3.1　使用属性动画"></a>7.3.1　使用属性动画</h3><p>属性动画可以对任意对象的属性进行动画而不仅仅是View，动画默认时间间隔300ms，默认帧率10ms&#x2F;帧。其可以达到的效果是：在一个时间间隔内完成对象从一个属性值到另一个属性值的改变。因此，属性动画几乎是无所不能的，只要对象有这个属性，它都能实现动画</p>
<p>效果。但是属性动画从API 11才有，这就严重制约了属性动画的使用。可以采用开源动画库nineoldandroids来兼容以前的版本，采用nineoldandroids，可以在API 11以前的系统上使用属性动画，nineoldandroids的网址是：<a target="_blank" rel="noopener" href="http://nineoldandroids.com/">http://nineoldandroids.com</a>。</p>
<p>Nineoldandroids对属性动画做了兼容，在API 11以前的版本其内部是通过代理View动画来实现的，因此在Android低版本上，它的本质还是View动画，尽管使用方法看起来是属性动画。Nineoldandroids的功能和系统原生对的android.animation.*中类的功能完全一致，使用方法也完全一样，只要我们用nineoldandroids来编写动画，就可以在所有的Android系统上运行。比较常用的几个动画类是：ValueAnimator、ObjectAnimator和AnimatorSet，其中ObjectAnimator继承自ValueAnimator，AnimatorSet是动画集合，可以定义一组动画，它们使用起来也是极其简单的。如何使用属性动画呢？下面简单举几个小例子，读者一看就明白了。</p>
<p>（1）改变一个对象（myObject）的translationY属性，让其沿着Y轴向上平移一段距离：它的高度，该动画在默认时间内完成，动画的完成时间是可以定义的。想要更灵活的效果我们还可以定义插值器和估值算法，但是一般来说我们不需要自定义，系统已经预置了一些，能够满足常用的动画。</p>
<p>ObjectAnimator.ofFloat(myObject,”translationY”,-myObject.getHeight()).</p>
<p>    start();</p>
<p>（2）改变一个对象的背景色属性，典型的情形是改变View的背景色，下面的动画可以让背景色在3秒内实现从0xFFFF8080到0xFF8080FF的渐变，动画会无限循环而且会有反转的效果。</p>
<p>ValueAnimator colorAnim &#x3D; ObjectAnimator.ofInt(this,”backgroundColor”,</p>
<p>     &#x2F;<em>Red</em>&#x2F;0xFFFF8080,&#x2F;<em>Blue</em>&#x2F;0xFF8080FF);</p>
<p>    colorAnim.setDuration(3000);</p>
<p>    colorAnim.setEvaluator(new ArgbEvaluator());</p>
<p>    colorAnim.setRepeatCount(ValueAnimator.INFINITE);</p>
<p>    colorAnim.setRepeatMode(ValueAnimator.REVERSE);</p>
<p>    colorAnim.start();</p>
<p>（3）动画集合，5秒内对View的旋转、平移、缩放和透明度都进行了改变。</p>
<p>AnimatorSet set &#x3D; new AnimatorSet();</p>
<p>    set.playTogether(</p>
<p>         ObjectAnimator.ofFloat(myView,”rotationX”,0,360),</p>
<p>         ObjectAnimator.ofFloat(myView,”rotationY”,0,180),</p>
<p>         ObjectAnimator.ofFloat(myView,”rotation”,0,-90),</p>
<p>         ObjectAnimator.ofFloat(myView,”translationX”,0,90),</p>
<p>         ObjectAnimator.ofFloat(myView,”translationY”,0,90),</p>
<p>         ObjectAnim</p>
<p>ator.ofFloat(myView,”scaleX”,1,1.5f),</p>
<p>         ObjectAnimator.ofFloat(myView,”scaleY”,1,0.5f),</p>
<p>         ObjectAnimator.ofFloat(myView,”alpha”,1,0.25f,1)</p>
<p>     );</p>
<p>    set.setDuration(5 * 1000).start();</p>
<p>属性动画除了通过代码实现以外，还可以通过XML来定义。属性动画需要定义在res&#x2F;animator&#x2F;目录下，它的语法如下所示。</p>
<p>&lt;set</p>
<p>       android:ordering&#x3D;[“together” | “sequentially”]&gt;</p>
<p>         &lt;objectAnimator</p>
<p>             android:propertyName&#x3D;”string”</p>
<p>             android:duration&#x3D;”int”</p>
<p>             android:valueFrom&#x3D;”float | int | color”</p>
<p>             android:valueTo&#x3D;”float | int | color”</p>
<p>             android:startOffset&#x3D;”int”</p>
<p>             android:repeatCount&#x3D;”int”</p>
<p>             android:repeatMode&#x3D;[“repeat” | “reverse”]</p>
<p>             android:valueType&#x3D;[“intType” | “floatType”]&#x2F;&gt;</p>
<p>         &lt;animator</p>
<p>             android:duration&#x3D;”int”</p>
<p>             android:valueFrom&#x3D;”float | int | color”</p>
<p>             android:valueTo&#x3D;”float | int | color”</p>
<p>             android:startOffset&#x3D;”int”</p>
<p>             android:repeatCount&#x3D;”int”</p>
<p>             android:repeatMode&#x3D;[“repeat” | “reverse”]</p>
<p>             android:valueType&#x3D;[“intType” | </p>
<p>“floatType”]&#x2F;&gt;</p>
<p>         <set></p>
<p>             …</p>
<p>         </set></p>
<p>    </set></p>
<p>属性动画的各种参数都比较好理解，在XML中可以定义ValueAnimator、Object-Animator以及AnimatorSet，其中<set>标签对应AnimatorSet，<Animator>标签对应ValueAnimator，而<objectAnimator>则对应ObjectAnimator。<set>标签的android:ordering属性有两个可选值：“together”和“sequentially”，其中“together”表示动画集合中的子动画同时播放，“sequentially”则表示动画集合中的子动画按照前后顺序依次播放，android:ordering属性的默认值是“together”。</p>
<p>对于<objectAnimator>标签的各个属性的含义，下面简单说明一下，对于<Animator>标签这里就不再介绍了，因为它只是比<objectAnimator>少了一个android:propertyName属性而已，其他都是一样的。</p>
<p>android:propertyName——表示属性动画的作用对象的属性的名称；</p>
<p>android:duration——表示动画的时长；</p>
<p>android:valueFrom——表示属性的起始值；</p>
<p>android:valueTo——表示属性的结束值；</p>
<p>android:startOffset——表示动画的延迟时间，当动画开始后，需要延迟多少毫秒才会真正播放此动画；</p>
<p>android:repeatCount——表示动画的重复次数；</p>
<p>android:repeatMode——表示动画的重复模式；</p>
<p>android:valueType——表示android:propertyName所指定的属性的类型，有“intType”和“floatType”两个可选项，分别表示属性的类型为整型和浮点型。另外，如果android:propertyName所指定的属性表示的是颜色，那么不需要指定android:valueType，系统会自动对颜色类型的属性做处理。</p>
<p>对于一个动画来说，有两个属性这里要特殊说明一下，一个是android:repeatCount，它表示动画循环的次数，默认值为0，其中-1表示无限循环；另一个是android:repeatMode，它表示动画循环的模式，有两个选项：“repeat”和“reverse”，分别表示连续重复和逆向重复。连续重复比较好理解，就是动画每次都重新开始播放，而逆向重复是指第一次播放完以后，第二次会倒着播放动画，第三次再重头开始播放动画，第四次再倒着播放动画，如此反复。</p>
<p>下面是一个具体的例子，我们通过XML定义一个属性动画并将其作用在View上，如下所示。</p>
<p>&#x2F;&#x2F; res&#x2F;animator&#x2F;property_animator.xml</p>
<p>    </p>
<set android:ordering="together">

<p>        &lt;objectAnimator</p>
<p>                android:propertyName&#x3D;”x”</p>
<p>                android:duration&#x3D;”300”</p>
<p>                android:valueTo&#x3D;”200”</p>
<p>                android:valueType&#x3D;”intType”&#x2F;&gt;</p>
<p>        &lt;objectAnimator</p>
<p>                android:propertyName&#x3D;”y”</p>
<p>                android:duration&#x3D;”300”</p>
<p>                android:valueTo&#x3D;”300”</p>
<p>                android:valueType&#x3D;”intType”&#x2F;&gt;</p>
<p>    </set></p>
<p>如何使用上面的属性动画呢？也很简单，如下所示。</p>
<p>AnimatorSet set &#x3D; (AnimatorSet) AnimatorInflater.loadAnimator(myContext,</p>
<p>    R.anim.property_animator);</p>
<p>    set.setTarget(mButton);</p>
<p>    set.start();</p>
<p>在实际开发中建议采用代码来实现属性动画，这是因为通过代码来实现比较简单。更重要的是，很多时候一个属性的起始值是无法提前确定的，比如让一个Button从屏幕左边移动到屏幕的右边，由于我们无法提前知道屏幕的宽度，因此无法将属性动画定义在XML中，在这种情况下就必须通过代码来动态地创建属性动画。</p>
<h3 id="7-3-2-理解插值器和估值器"><a href="#7-3-2-理解插值器和估值器" class="headerlink" title="7.3.2　理解插值器和估值器"></a>7.3.2　理解插值器和估值器</h3><p>TimeInterpolator中文翻译为时间插值器</p>
<p>，它的作用是根据时间流逝的百分比来计算出当前属性值改变的百分比，系统预置的有LinearInterpolator（线性插值器：匀速动画）、AccelerateDecelerateInterpolator（加速减速插值器：动画两头慢中间快）和Decelerate-Interpolator（减速插值器：动画越来越慢）等。TypeEvaluator的中文翻译为类型估值算法，也叫估值器，它的作用是根据当前属性改变的百分比来计算改变后的属性值，系统预置的有IntEvaluator（针对整型属性）、FloatEvaluator（针对浮点型属性）和ArgbEvaluator（针对Color属性）。属性动画中的插值器（Interpolator）和估值器（TypeEvaluator）很重要，它们是实现非匀速动画的重要手段。可能这么说还有点晦涩，没关系，下面给出一个实例就很好理解了。</p>
<p>如图7-1所示，它表示一个匀速动画，采用了线性插值器和整型估值算法，在40ms内，View的x属性实现从0到40的变换。</p>
<p>图7-1　插值器的工作原理（注：此图来自Android官方文档）</p>
<p>由于动画的默认刷新率为10ms&#x2F;帧，所以该</p>
<p>动画将分5帧进行，我们来考虑第三帧（x&#x3D;20，t&#x3D;20ms），当时间t&#x3D;20ms的时候，时间流逝的百分比是0.5（20&#x2F;40&#x3D;0.5），意味着现在时间过了一半，那x应该改变多少呢？这个就由插值器和估值算法来确定。拿线性插值器来说，当时间流逝一半的时候，x的变换也应该是一半，即x的改变是0.5，为什么呢？因为它是线性插值器，是实现匀速动画的，下面看它的源码：</p>
<p>public class LinearInterpolator implements Interpolator {</p>
<p>         public LinearInterpolator() {</p>
<p>         }</p>
<p>         public LinearInterpolator(Context context,AttributeSet attrs) {</p>
<p>         }</p>
<p>         public float getInterpolation(float input) {</p>
<p>             return input;</p>
<p>         }</p>
<p>    }</p>
<p>很显然，线性插值器的返回值和输入值一样，因此插值器返回的值是0.5，这意味着x的改变是0.5，这个时候插值器的工作就完成了。具体x变成了什么值，这个需要估值算法来确定，我们来看看整型估值算法的源码：</p>
<p>public class IntEvaluator implements TypeEvaluator<Integer> {</p>
<p>         public Integer evaluate(float fraction,Integer startValue,Integer</p>
<p>         endValue) {</p>
<p>             int startInt &#x3D; startValue;</p>
<p>             return (int)(startInt + fraction * (endValue -startInt));</p>
<p>         }</p>
<p>    }</p>
<p>上述算法很简单，evaluate的三个参数分别表示估值小数、开始值和结束值，对应于我们的例子就分别是0.5、0、40。根据上述算法，整型估值返回给我们的结果是20，这就是（x&#x3D;20，t&#x3D;20ms）的由来。</p>
<p>属性动画要求对象的该属性有set方法和get方法（可选）。插值器和估值算法除了系统提供的外，我们还可以自定义。实现方式也很简单，因为插值器和估值算法都是一个接口，且内部都只有一个方法，我们只要派生一个类实现接口就可以了，然后就可以做出千奇百怪的动画效果了。具体一点就是：自定义插值器需要实现Interpolator或者TimeInter-polator，自定义估值算法需要实现TypeEvaluator。另外就是如果要对其他类型（非int、float、Color）做动画，那么必须要自定义类型估值算法。</p>
<h3 id="7-3-3-属性动画的监听器"><a href="#7-3-3-属性动画的监听器" class="headerlink" title="7.3.3　属性动画的监听器"></a>7.3.3　属性动画的监听器</h3><p>属性动画提供了监听器用于监听动画的播放过程，主要有如下两个接口：AnimatorUpdateListener和AnimatorListener。</p>
<p>AnimatorListener的定义如下：</p>
<p>public static interface AnimatorListener {</p>
<p>        void onAnimationStart(Animator animation);</p>
<p>        void onAnimationEnd(Animator animation);</p>
<p>        void onAnimationCancel(Animator animation);</p>
<p>        void o</p>
<p>nAnimationRepeat(Animator animation);</p>
<p>    }</p>
<p>从AnimatorListener的定义可以看出，它可以监听动画的开始、结束、取消以及重复播放。同时为了方便开发，系统还提供了AnimatorListenerAdapter这个类，它是Animator-Listener的适配器类，这样我们就可以有选择地实现上面的4个方法了，毕竟不是所有方法都是我们感兴趣的。</p>
<p>下面再看一下AnimatorUpdateListener的定义，如下所示。</p>
<p>public static interface AnimatorUpdateListener {</p>
<p>        void onAnimationUpdate(ValueAnimator animation);</p>
<p>    }</p>
<p>AnimatorUpdateListener比较特殊，它会监听整个动画过程，动画是由许多帧组成的，每播放一帧，onAnimationUpdate就会被调用一次，利用这个特性，我们可以做一些特殊的事情。</p>
<h3 id="7-3-4-对任意属性做动画"><a href="#7-3-4-对任意属性做动画" class="headerlink" title="7.3.4　对任意属性做动画"></a>7.3.4　对任意属性做动画</h3><p>这里先提出一个问题：给Button加一个动画，让这个Button的宽度从当前宽度增加到500px。也许你会说，这很简单，用View动画就可以搞定，我们可以来试试，你能写出来吗？很快你就会恍然大悟，原来View动画根本不支持对宽度进行动画。没错，View动画只支持四种</p>
<p>类型：平移（Translate）、旋转（Rotate）、缩放（Scale）、不透明度（Alpha）。当然用x方向缩放（scaleX）可以让Button在x方向放大，看起来好像是宽度增加了，实际上不是，只是Button被放大了而已，而且由于只x方向被放大，这个时候Button的背景以及上面的文本都被拉伸了，甚至有可能Button会超出屏幕，如图7-2所示。</p>
<p>图7-2　属性动画的缩放效果</p>
<p>图7-2中的效果显然是很差的，而且也不是真正地对宽度做动画，不过，所幸我们还有属性动画，我们用属性动画试试，如下所示。</p>
<p>private void performAnimate() {</p>
<p>        ObjectAnimator.ofInt(mButton,”width”,500).setDuration(5000).start();</p>
<p>    }</p>
<p>    @Override</p>
<p>    public void onClick(View v) {</p>
<p>        if (v &#x3D;&#x3D; mButton) {</p>
<p>                performAnimate();</p>
<p>        }</p>
<p>    }</p>
<p>上述代码运行后发现没效果，其实没效果是对的，如果随便传递一个属性过去，轻则没动画效果，重则程序直接Crash。</p>
<p>下面分析属性动画的原理：属性动画要求动画作用的对象提供该属性的get和set方法，属性动画根据外界传递的该属性的初始值和最终值，以动画的效果多次去调用set方法，每次传递给set方法的值都不一样，确切来说是随着时间的推移，所传递的值越来越接近最终值。总结一下，我们对object的属性abc做动画，如果想让动画生效，要同时满足两个条件：</p>
<p>（1）object必须要提供setAbc方法，如果动画的时候没有传递初始值，那么还要提供getAbc方法，因为系统要去取abc属性的初始值（如果这条不满足，程序直接Crash）。</p>
<p>（2）object的setAbc对属性abc所做的改变必须能够通过某种方法反映出来，比如会带来UI的改变之类的（如果这条不满足，动画无效果但不会Crash）。</p>
<p>以上条件缺一不可。那么为什么我们对Button的width属性做动画会没有效果？这是因为Button内部虽然提供了getWidth和setWidth方法，但是这个setWidth方法并不是改变视图的大小，它是TextView新添加的方法，View是没有这个setWidth方法的，由于Button继承了TextView，所以Button也就有了setWidth方法。下面看一下这个getWidth和setWidth方法的源码：</p>
<p>&#x2F;**</p>
<p>      * Makes the TextView exactly thi</p>
<p>s many pixels wide.</p>
<p>      * You could do the same thing by specifying this number in the</p>
<p>      * LayoutParams.</p>
<p>      *</p>
<p>      * @see #setMaxWidth(int)</p>
<p>      * @see #setMinWidth(int)</p>
<p>      * @see #getMinWidth()</p>
<p>      * @see #getMaxWidth()</p>
<p>      *</p>
<p>      * @attr ref android.R.styleable#TextView_width</p>
<p>      *&#x2F;</p>
<p>    @android.view.RemotableViewMethod</p>
<p>    public void setWidth(int pixels) {</p>
<p>        mMaxWidth &#x3D; mMinWidth &#x3D; pixels;</p>
<p>        mMaxWidthMode &#x3D; mMinWidthMode &#x3D; PIXELS;</p>
<p>        requestLayout();</p>
<p>        invalidate();</p>
<p>    }</p>
<p>     &#x2F;**</p>
<p>      * Return the width of the your view.</p>
<p>      *</p>
<p>      * @return The width of your view,in pixels.</p>
<p>      *&#x2F;</p>
<p>    @ViewDebug.ExportedProperty(category &#x3D; “layout”)</p>
<p>    public final int getWidth() {</p>
<p>        return mRight -mLeft;</p>
<p>    }</p>
<p>从上述源码可以看出，getWidth的确是获取View的宽度的，而setWidth是TextView和其子类的专属方法，它的作用不是设置View的宽度，而是设置TextView的最大宽度和最小宽度的，这个和TextView的宽度不是一个东西。具体来说，TextView的宽度对应XML中的android:layout_width属性，而TextView还有一个属性android:width，这个android:width属性就对应了TextView的setWidth方法。总之，TextView</p>
<p>和Button的setWidth、getWidth干的不是同一件事情，通过setWidth无法改变控件的宽度，所以对width做属性动画没有效果。对应于属性动画的两个条件来说，本例中动画不生效的原因是只满足了条件1而未满足条件2。</p>
<p>针对上述问题，官方文档上告诉我们有3种解决方法：</p>
<p>给你的对象加上get和set方法，如果你有权限的话；</p>
<p>用一个类来包装原始对象，间接为其提供get和set方法；</p>
<p>采用ValueAnimator，监听动画过程，自己实现属性的改变。</p>
<p>针对上面提出的三种解决方法，下面给出具体的介绍。</p>
<ol>
<li>给你的对象加上get和set方法，如果你有权限的话</li>
</ol>
<p>这个的意思很好理解，如果你有权限的话，加上get和set就搞定了。但是很多时候我们没权限去这么做。比如本文开头所提到的问题，你无法给Button加上一个合乎要求的setWidth方法，因为这是Android SDK内部实现的。这个方法最简单，但是往往是不可行的，这里就不对其进行更多的分析了。</p>
<ol start="2">
<li>用一个类来包装原始对象，间接为其提供get和set方法</li>
</ol>
<p>这是一个很有用的解决方法，是笔者最喜欢用的，因为用起来很方便，也很好理解，下面将通过一个具体的例子来介绍它。</p>
<p>private void performAnimate() {</p>
<p>        ViewWrapper wrapper &#x3D; new ViewWrapper(mButton);</p>
<p>        ObjectAnimator.ofInt(wrapper,”width”,500).setDuration(5000).start();</p>
<p>    }</p>
<p>    @Override</p>
<p>    public void onClick(View v) {</p>
<p>        if (v &#x3D;&#x3D; mButton) {</p>
<p>                performAnimate();</p>
<p>        }</p>
<p>    }</p>
<p>    private static class ViewWrapper {</p>
<p>        private View mTarget;</p>
<p>        public ViewWrapper(View target) {</p>
<p>                mTarget &#x3D; target;</p>
<p>        }</p>
<p>        public int getWidth() {</p>
<p>                return mTarget.getLayoutParams().width;</p>
<p>        }</p>
<p>        public void setWidth(int width) {</p>
<p>                mTarget.getLayoutParams().width &#x3D; width;</p>
<p>                mTarget.requestLayout();</p>
<p>        }</p>
<p>    }</p>
<p>图7-3　属性动画对宽度做动画的效果</p>
<p>上述代码在5s内让Button的宽度增加到了500px，为了达到这个效果，我们提供了ViewWrapper类专门用于包装View，具体到本例是包装Button。然后我们对ViewWrapper的width属性做动画，并且在setWidth方法中修改其内部的target的宽度，而target实际上就是我们包装的Button。这样一个间接属性动画就搞定了，上述代码同样适用于一个对象的其他属性。如图7-3所示，很显然效果达到了，真正实现了对宽度做动画。</p>
<ol start="3">
<li>采用ValueAnimator，监听动画过程，自己实现属性的改变</li>
</ol>
<p>首先说说什么是ValueAnimator，ValueAnimator本身不作用于任何对象，也就是说直接使用它没有任何动画效果。它可以对一个值做动画，然后我们可以监听其动画过程，在动画过程中修改我们的对象的属性值，这样也就相当于我们的对象做了动画。下面用例子来说明：</p>
<p>private void performAnimate(final View target,final int start,final int</p>
<p>    end) {</p>
<p>        ValueAnimator valueAnimator &#x3D; ValueAnimator.ofInt(1,100);</p>
<p>        valueAnimator.addUpdateListener(new AnimatorUpdateListener() {</p>
<p>                &#x2F;&#x2F; 持有一个IntEvaluator对象，方便下面估值的时候使用</p>
<p>                private IntEvaluator mEvaluator &#x3D; new IntEvaluator();</p>
<p>         </p>
<p>@Override</p>
<p>                public void onAnimationUpdate(ValueAnimator animator) {</p>
<p>                        &#x2F;&#x2F; 获得当前动画的进度值，整型，1~100之间</p>
<p>                        int currentValue &#x3D; (Integer) animator.getAnimatedValue();</p>
<p>                        Log.d(TAG,”current value: “ + currentValue);</p>
<p>                        &#x2F;&#x2F; 获得当前进度占整个动画过程的比例，浮点型，0~1之间</p>
<p>                        float fraction &#x3D; animator.getAnimatedFraction();</p>
<p>                        &#x2F;&#x2F; 直接调用整型估值器，通过比例计算出宽度，然后再设给Button</p>
<p>                        target.getLayoutParams().width &#x3D; mEvaluator.evaluate(fraction,start,end);</p>
<p>                        target.requestLayout();</p>
<p>                }</p>
<p>        });</p>
<p>        valueAnimator.setDuration(5000).start();</p>
<p>    }</p>
<p>    @Override</p>
<p>    public void onClick(View v) {</p>
<p>        if (v &#x3D;&#x3D; mButton) {</p>
<p>                performAnimate(mButton,mButton.getWidth(),500);</p>
<p>        }</p>
<p>    }</p>
<p>上述代码的效果图和采用ViewWrapper是一样的，请参看图7-3。关于这个ValueAnimator要再说一下，拿上面的例子来说，它会在5000ms内将一个数从1变到100，然后动画的每一帧会回调onAnimationUpdate方法。在这个方法里</p>
<p>，我们可以获取当前的值（1～100）和当前值所占的比例，我们可以计算出Button现在的宽度应该是多少。比如时间过了一半，当前值是50，比例为0.5，假设Button的起始宽度是100px，最终宽度是500px，那么Button增加的宽度也应该占总增加宽度的一半，总增加宽度是500－100&#x3D;400，所以这个时候Button应该增加的宽度是400×0.5&#x3D;200，那么当前Button的宽度应该为初始宽度 + 增加宽度（100+200&#x3D;300）。上述计算过程很简单，其实它就是整型估值器IntEvaluator的内部实现，所以我们不用自己写了，直接用吧。</p>
<p>7.3.5　属性动画的工作原理</p>
<p>属性动画要求动画作用的对象提供该属性的set方法，属性动画根据你传递的该属性的初始值和最终值，以动画的效果多次去调用set方法。每次传递给set方法的值都不一样，确切来说是随着时间的推移，所传递的值越来越接近最终值。如果动画的时候没有传递初始值，那么还要提供get方法，因为系统要去获取属性的初始值。对于属性动画来说，其动画过程中所做的就是这么多，下面看源码分析。</p>
<p>首先我们要找一个入口，就从ObjectAnimator.ofInt(mButton,”width”,500).setDuration (5000).start()开始，其他动画都是类似的。先看ObjectAnimator的start方法：</p>
<p>public void start() {</p>
<p>        &#x2F;&#x2F; See if any of the current active&#x2F;pending animators need to be canceled</p>
<p>        AnimationHandler handler &#x3D; sAnimationHandler.get();</p>
<p>        if (handler !&#x3D; null) {</p>
<p>                int numAnims &#x3D; handler.mAnimations.size();</p>
<p>                for (int i &#x3D; numAnims -1; i &#x3D;&gt; 0; i–) {</p>
<p>                        if (handler.mAnimations.get(i) instanceof ObjectAnimator) {</p>
<p>                                ObjectAnimator anim &#x3D; (ObjectAnimator) handler.mAnimations.get(i);</p>
<p>                                if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) {</p>
<p>                                        anim.cancel();</p>
<p>                                }</p>
<p>                        }</p>
<p>                }</p>
<p>                numAnims &#x3D; handler.mPendingAnimations.size();</p>
<p>                for (int i &#x3D; numAnims -1; i &#x3D;&gt; 0; i–) {</p>
<p>                        if (handler.mPendingAnimations.get(i) instanceof ObjectAnimator) {</p>
<p>                                ObjectAnimator anim &#x3D; (ObjectAnimator) handler.mPending-Animations.get(i);</p>
<p>                                if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) {</p>
<p>            </p>
<p> anim.cancel();</p>
<p>                                }</p>
<p>                        }</p>
<p>                }</p>
<p>                numAnims &#x3D; handler.mDelayedAnims.size();</p>
<p>                for (int i &#x3D; numAnims -1; i &#x3D;&gt; 0; i–) {</p>
<p>                        if (handler.mDelayedAnims.get(i) instanceof ObjectAnimator) {</p>
<p>                                ObjectAnimator anim &#x3D; (ObjectAnimator) handler.mDelayed-</p>
<p>                                Anims.get(i);</p>
<p>                                if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) {</p>
<p>                                        anim.cancel();</p>
<p>上面的代码别看那么长，其实做的事情很简单，首先会判断如果当前动画、等待的动画（Pending）和延迟的动画（Delay）中有和当前动画相同的动画，那么就把相同的动画给取消掉，接下来那一段是log，再接着就调用了父类的super.start()方法。因为ObjectAnimator继承了ValueAnimator，所以接下来我们看一下ValueAnimator的Start方法：</p>
<p>private void start(boolean playBackwards) {</p>
<p>        if (Looper.myLooper() &#x3D;&#x3D; null) {</p>
<p>                throw new AndroidRuntimeException(“Animators may only be run on Looper threads”);</p>
<p>        }</p>
<p>        mPlayingBackwards &#x3D; playBackwards;</p>
<p>        mCurre</p>
<p>ntIteration &#x3D; 0;</p>
<p>        mPlayingState &#x3D; STOPPED;</p>
<p>        mStarted &#x3D; true;</p>
<p>        mStartedDelay &#x3D; false;</p>
<p>        mPaused &#x3D; false;</p>
<p>        updateScaledDuration(); &#x2F;&#x2F; in case the scale factor has changed since           creation time</p>
<p>        AnimationHandler animationHandler &#x3D; getOrCreateAnimationHandler();</p>
<p>        animationHandler.mPendingAnimations.add(this);</p>
<p>        if (mStartDelay &#x3D;&#x3D; 0) {</p>
<p>                &#x2F;&#x2F; This sets the initial value of the animation,prior to actually starting it running</p>
<p>                setCurrentPlayTime(0);</p>
<p>                mPlayingState &#x3D; STOPPED;</p>
<p>                mRunning &#x3D; true;</p>
<p>                notifyStartListeners();</p>
<p>        }</p>
<p>        animationHandler.start();</p>
<p>    }</p>
<p>可以看出属性动画需要运行在有Looper的线程中。上述代码最终会调用Animation-Handler的start方法，这个AnimationHandler并不是Handler，它是一个Runnable。看一下它的代码，通过代码我们发现，很快就调到了JNI层，不过JNI层最终还是要调回来的。它的run方法会被调用，这个Runnable涉及和底层的交互，我们就忽略这部分，直接看重点：ValueAnimator中的doAnimationFrame方法，如下所示。</p>
<p>final boolean doAnimationFrame(long frame</p>
<p>Time) {</p>
<p>        if (mPlayingState &#x3D;&#x3D; STOPPED) {</p>
<p>                mPlayingState &#x3D; RUNNING;</p>
<p>                if (mSeekTime &lt; 0) {</p>
<p>                        mStartTime &#x3D; frameTime;</p>
<p>                } else {</p>
<p>                        mStartTime &#x3D; frameTime -mSeekTime;</p>
<p>                        &#x2F;&#x2F; Now that we’re playing,reset the seek time</p>
<p>                        mSeekTime &#x3D; -1;</p>
<p>                }</p>
<p>        }</p>
<p>        if (mPaused) {</p>
<p>                if (mPauseTime &lt; 0) {</p>
<p>                        mPauseTime &#x3D; frameTime;</p>
<p>                }</p>
<p>                return false;</p>
<p>        } else if (mResumed) {</p>
<p>                mResumed &#x3D; false;</p>
<p>                if (mPauseTime &gt; 0) {</p>
<p>        &#x2F;&#x2F; Offset by the duration that the animation was paused</p>
<p>                        mStartTime +&#x3D; (frameTime -mPauseTime);</p>
<p>                }</p>
<p>        }</p>
<p>    &#x2F;&#x2F; The frame time might be before the start time during the first frame of</p>
<p>    &#x2F;&#x2F; an animation. The “current time” must always be on or after the start</p>
<p>    &#x2F;&#x2F; time to avoid animating frames at negative time intervals. In practice,this</p>
<p>    &#x2F;&#x2F; is very rare and only happens when seeking backwards.</p>
<p>        final long currentTime &#x3D; Math.max(frameT</p>
<p>ime,mStartTime);</p>
<p>        return animationFrame(currentTime);</p>
<p>    }</p>
<p>注意到上述代码末尾调用了animationFrame方法，而animationFrame内部调用了animateValue，下面看animateValue的代码：</p>
<p>void animateValue(float fraction) {</p>
<p>        fraction &#x3D; mInterpolator.getInterpolation(fraction);</p>
<p>        mCurrentFraction &#x3D; fraction;</p>
<p>        int numValues &#x3D; mValues.length;</p>
<p>        for (int i &#x3D; 0; i &lt; numValues; ++i) {</p>
<p>                mValues[i].calculateValue(fraction);</p>
<p>        }</p>
<p>        if (mUpdateListeners !&#x3D; null) {</p>
<p>                int numListeners &#x3D; mUpdateListeners.size();</p>
<p>                for (int i &#x3D; 0; i &lt; numListeners; ++i) {</p>
<p>                        mUpdateListeners.get(i).onAnimationUpdate(this);</p>
<p>                }</p>
<p>        }</p>
<p>    }</p>
<p>上述代码中的calculateValue方法就是计算每帧动画所对应的属性的值，下面着重看一下到底是在哪里调用属性的get和set方法的，毕竟这个才是我们最关心的。</p>
<p>在初始化的时候，如果属性的初始值没有提供，则get方法将会被调用，请看Property-ValuesHolder的setupValue方法，可以发现get</p>
<p>方法是通过反射来调用的，如下所示。</p>
<p>private void setupValue(Object target,Keyframe kf) {</p>
<p>        if (mProperty !&#x3D; null) {</p>
<p>                Object value &#x3D; convertBack(mProperty.get(target));</p>
<p>                kf.setValue(value);</p>
<p>        }</p>
<p>        try {</p>
<p>                if (mGetter &#x3D;&#x3D; null) {</p>
<p>                        Class targetClass &#x3D; target.getClass();</p>
<p>                        setupGetter(targetClass);</p>
<p>                        if (mGetter &#x3D;&#x3D; null) {</p>
<p>                                &#x2F;&#x2F; Already logged the error -just return to avoid NPE</p>
<p>                                return;</p>
<p>                        }</p>
<p>                }</p>
<p>                Object value &#x3D; convertBack(mGetter.invoke(target));</p>
<p>                kf.setValue(value);</p>
<p>        } catch (InvocationTargetException e) {</p>
<p>                Log.e(“PropertyValuesHolder”,e.toString());</p>
<p>        } catch (IllegalAccessException e) {</p>
<p>                Log.e(“PropertyValuesHolder”,e.toString());</p>
<p>        }</p>
<p>    }</p>
<p>当动画的下一帧到来的时候，PropertyValuesHolder中的setAnimatedValue方法会将新的属性值设置给对象，调用其set方法。从下面的源码可以看出，set方法也是通过反射来调用的：</p>
<p>void setAnimatedValue(Object target) {</p>
<p>        if (mProperty !&#x3D; null) {</p>
<p>                mProperty.set(target,getAnimatedValue());</p>
<p>        }</p>
<p>        if (mSetter !&#x3D; null) {</p>
<p>                try {</p>
<p>                        mTmpValueArray[0] &#x3D; getAnimatedValue();</p>
<p>                        mSetter.invoke(target,mTmpValueArray);</p>
<p>                } catch (InvocationTargetException e) {</p>
<p>                        Log.e(“PropertyValuesHolder”,e.toString());</p>
<p>                } catch (IllegalAccessException e) {</p>
<p>                        Log.e(“PropertyValuesHolder”,e.toString());</p>
<p>                }</p>
<p>        }</p>
<p>    }</p>
<h2 id="7-4-使用动画的注意事项"><a href="#7-4-使用动画的注意事项" class="headerlink" title="7.4　使用动画的注意事项"></a>7.4　使用动画的注意事项</h2><p>通过动画可以实现一些比较绚丽的效果，但是在使用过程中，也需要注意一些事情，主要分为下面几类。</p>
<ol>
<li>OOM问题</li>
</ol>
<p>这个问题主要出现在帧动画中，当图片数量较多且图片较大时就极易出现OOM，这个在实际的开发中要尤其注意，尽量避免使用帧动画。</p>
<ol start="2">
<li>内存泄露</li>
</ol>
<p>在属性动画中有一类无限循环的动画，这</p>
<p>类动画需要在Activity退出时及时停止，否则将导致Activity无法释放从而造成内存泄露，通过验证后发现View动画并不存在此问题。</p>
<ol start="3">
<li>兼容性问题</li>
</ol>
<p>动画在3.0以下的系统上有兼容性问题，在某些特殊场景可能无法正常工作，因此要做好适配工作。</p>
<ol start="4">
<li>View动画的问题</li>
</ol>
<p>View动画是对View的影像做动画，并不是真正地改变View的状态，因此有时候会出现动画完成后View无法隐藏的现象，即setVisibility(View.GONE)失效了，这个时候只要调用view.clearAnimation()清除View动画即可解决此问题。</p>
<ol start="5">
<li>不要使用px</li>
</ol>
<p>在进行动画的过程中，要尽量使用dp，使用px会导致在不同的设备上有不同的效果。</p>
<ol start="6">
<li>动画元素的交互</li>
</ol>
<p>将view移动（平移）后，在Android 3.0以前的系统上，不管是View动画还是属性动画，新位置均无法触发单击事件，同时，老位置仍然可以触发单击事件。尽管View已经在视觉上不存在了，将View移回原位置以后，原位置的单击事件继续生效。从3.0开始，属性动画的单击事件触发位置为移动后的位置，但是View动画仍然在原位置。</p>
<ol start="7">
<li>硬件加速</li>
</ol>
<p>使用动画的过程中，建议开启硬件加速，这样会提高动画的流畅性。</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/android/">android</a></div><div class="post_share"><div class="social-share" data-image="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2Fd5f80e1a-f4c1-4f5c-aad2-fe213ae89f64%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&amp;refer=http%3A%2F%2Fsafe-img.xhscdn.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1710160772&amp;t=4038984b7822fc46c9a8d50e0c5106b4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/01/06/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC6%E7%AB%A0%20Android%E7%9A%84Drawable/" title="第六章　Android的Drawable"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第六章　Android的Drawable</div></div></a></div><div class="next-post pull-right"><a href="/2021/01/08/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC8%E7%AB%A0%20%E7%90%86%E8%A7%A3Window%E5%92%8CWindowManager/" title="第八章　理解Windows和WindowManager"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第八章　理解Windows和WindowManager</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/01/11/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC11%E7%AB%A0%20Android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="第十一章　Android的线程和线程池"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-11</div><div class="title">第十一章　Android的线程和线程池</div></div></a></div><div><a href="/2021/01/10/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC10%E7%AB%A0%20Android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/" title="第十章　Android的消息机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-10</div><div class="title">第十章　Android的消息机制</div></div></a></div><div><a href="/2021/01/13/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC13%E7%AB%A0%20%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/" title="第十三章 综合技术"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-13</div><div class="title">第十三章 综合技术</div></div></a></div><div><a href="/2021/01/15/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC15%E7%AB%A0%20Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="第十五章 Android性能优化"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-15</div><div class="title">第十五章 Android性能优化</div></div></a></div><div><a href="/2021/01/12/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC12%E7%AB%A0%20Bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8CCache/" title="第十二章　Bitmap的加载和Cache"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-12</div><div class="title">第十二章　Bitmap的加载和Cache</div></div></a></div><div><a href="/2021/01/03/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC3%E7%AB%A0%20View%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/" title="第三章　View的事件体系"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-03</div><div class="title">第三章　View的事件体系</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fsafe-img.xhscdn.com%2Fbw1%2Fd5f80e1a-f4c1-4f5c-aad2-fe213ae89f64%3FimageView2%2F2%2Fw%2F1080%2Fformat%2Fjpg&amp;refer=http%3A%2F%2Fsafe-img.xhscdn.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1710160772&amp;t=4038984b7822fc46c9a8d50e0c5106b4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Junyong Tu</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" href="https://github.com/juncaixingchi1993"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-View%E5%8A%A8%E7%94%BB"><span class="toc-number">1.</span> <span class="toc-text">7.1　View动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-View%E5%8A%A8%E7%94%BB%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">7.1.1　View动画的种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-2-%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%8A%A8%E7%94%BB"><span class="toc-number">1.2.</span> <span class="toc-text">7.1.2　自定义View动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-3-%E5%B8%A7%E5%8A%A8%E7%94%BB"><span class="toc-number">1.3.</span> <span class="toc-text">7.1.3　帧动画</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-View%E5%8A%A8%E7%94%BB%E7%9A%84%E7%89%B9%E6%AE%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.</span> <span class="toc-text">7.2　View动画的特殊使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-LayoutAnimation"><span class="toc-number">2.1.</span> <span class="toc-text">7.2.1　LayoutAnimation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-Activity%E7%9A%84%E5%88%87%E6%8D%A2%E6%95%88%E6%9E%9C"><span class="toc-number">2.2.</span> <span class="toc-text">7.2.2　Activity的切换效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB"><span class="toc-number">3.</span> <span class="toc-text">7.3　属性动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-1-%E4%BD%BF%E7%94%A8%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB"><span class="toc-number">3.1.</span> <span class="toc-text">7.3.1　使用属性动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-2-%E7%90%86%E8%A7%A3%E6%8F%92%E5%80%BC%E5%99%A8%E5%92%8C%E4%BC%B0%E5%80%BC%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">7.3.2　理解插值器和估值器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-3-%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E7%9A%84%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">7.3.3　属性动画的监听器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-4-%E5%AF%B9%E4%BB%BB%E6%84%8F%E5%B1%9E%E6%80%A7%E5%81%9A%E5%8A%A8%E7%94%BB"><span class="toc-number">3.4.</span> <span class="toc-text">7.3.4　对任意属性做动画</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E4%BD%BF%E7%94%A8%E5%8A%A8%E7%94%BB%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.</span> <span class="toc-text">7.4　使用动画的注意事项</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/10/gallery/" title="图库">图库</a><time datetime="2024-02-10T15:25:25.435Z" title="发表于 2024-02-10 23:25:25">2024-02-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/01/15/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC15%E7%AB%A0%20Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="第十五章 Android性能优化">第十五章 Android性能优化</a><time datetime="2021-01-15T14:07:08.000Z" title="发表于 2021-01-15 22:07:08">2021-01-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/01/14/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC14%E7%AB%A0%20JNI%E5%92%8CNDK%E7%BC%96%E7%A8%8B/" title="第十四章 JNI和NDK编程">第十四章 JNI和NDK编程</a><time datetime="2021-01-14T14:07:08.000Z" title="发表于 2021-01-14 22:07:08">2021-01-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/01/13/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC13%E7%AB%A0%20%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/" title="第十三章 综合技术">第十三章 综合技术</a><time datetime="2021-01-13T14:07:08.000Z" title="发表于 2021-01-13 22:07:08">2021-01-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/01/12/Android%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2/%E7%AC%AC12%E7%AB%A0%20Bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8CCache/" title="第十二章　Bitmap的加载和Cache">第十二章　Bitmap的加载和Cache</a><time datetime="2021-01-12T14:07:08.000Z" title="发表于 2021-01-12 22:07:08">2021-01-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Junyong Tu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>